<!DOCTYPE html><html class="theme-next mist use-motion" lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=6.4.0" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=6.4.0"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32.png?v=6.4.0"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16.png?v=6.4.0"><link rel="mask-icon" href="/images/logo.png?v=6.4.0" color="#222"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",version:"6.4.0",sidebar:{position:"left",display:"hide",offset:12,b2t:!1,scrollpercent:!0,onmobile:!0},fancybox:!1,fastclick:!1,lazyload:!1,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><meta name="description" content="Abstract: 数字图像处理：第46天Keywords: canny,边缘检测"><meta name="keywords" content="canny,边缘检测"><meta property="og:type" content="article"><meta property="og:title" content="\[数字图像处理\]6.8:灰度图像-图像分割 Canny边缘检测"><meta property="og:url" content="http://www.face2ai.com/DIP-6-8-灰度图像-图像分割-Canny边缘检测/index.html"><meta property="og:site_name" content="谭升的博客"><meta property="og:description" content="Abstract: 数字图像处理：第46天Keywords: canny,边缘检测"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://tony4ai-1251394096.cos.ap-hongkong.myqcloud.com/blog_images/DIP-6-8-灰度图像-图像分割-Canny边缘检测/20150212181022310.jpeg"><meta property="og:image" content="https://tony4ai-1251394096.cos.ap-hongkong.myqcloud.com/blog_images/DIP-6-8-灰度图像-图像分割-Canny边缘检测/20150212181924413.jpeg"><meta property="og:image" content="https://tony4ai-1251394096.cos.ap-hongkong.myqcloud.com/blog_images/DIP-6-8-灰度图像-图像分割-Canny边缘检测/20150212181937158.jpeg"><meta property="og:image" content="https://tony4ai-1251394096.cos.ap-hongkong.myqcloud.com/blog_images/DIP-6-8-灰度图像-图像分割-Canny边缘检测/20150212181953180.jpeg"><meta property="og:image" content="https://tony4ai-1251394096.cos.ap-hongkong.myqcloud.com/blog_images/DIP-6-8-灰度图像-图像分割-Canny边缘检测/20150212182006783.jpeg"><meta property="og:image" content="https://tony4ai-1251394096.cos.ap-hongkong.myqcloud.com/blog_images/DIP-6-8-灰度图像-图像分割-Canny边缘检测/20150212182025625.jpeg"><meta property="og:image" content="https://tony4ai-1251394096.cos.ap-hongkong.myqcloud.com/blog_images/DIP-6-8-灰度图像-图像分割-Canny边缘检测/20150212182315899.jpeg"><meta property="og:image" content="https://tony4ai-1251394096.cos.ap-hongkong.myqcloud.com/blog_images/DIP-6-8-灰度图像-图像分割-Canny边缘检测/20150212182333621.jpeg"><meta property="og:image" content="https://tony4ai-1251394096.cos.ap-hongkong.myqcloud.com/blog_images/DIP-6-8-灰度图像-图像分割-Canny边缘检测/20150212182345025.jpeg"><meta property="og:image" content="https://tony4ai-1251394096.cos.ap-hongkong.myqcloud.com/blog_images/DIP-6-8-灰度图像-图像分割-Canny边缘检测/20150212182356134.jpeg"><meta property="og:image" content="https://tony4ai-1251394096.cos.ap-hongkong.myqcloud.com/blog_images/DIP-6-8-灰度图像-图像分割-Canny边缘检测/20150212182416318.jpeg"><meta property="og:image" content="https://tony4ai-1251394096.cos.ap-hongkong.myqcloud.com/blog_images/DIP-6-8-灰度图像-图像分割-Canny边缘检测/20150212182426040.jpeg"><meta property="og:image" content="https://tony4ai-1251394096.cos.ap-hongkong.myqcloud.com/blog_images/DIP-6-8-灰度图像-图像分割-Canny边缘检测/20150212182449655.jpeg"><meta property="og:updated_time" content="2018-09-25T11:10:00.049Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="\[数字图像处理\]6.8:灰度图像-图像分割 Canny边缘检测"><meta name="twitter:description" content="Abstract: 数字图像处理：第46天Keywords: canny,边缘检测"><meta name="twitter:image" content="https://tony4ai-1251394096.cos.ap-hongkong.myqcloud.com/blog_images/DIP-6-8-灰度图像-图像分割-Canny边缘检测/20150212181022310.jpeg"><link rel="canonical" href="http://www.face2ai.com/DIP-6-8-灰度图像-图像分割-Canny边缘检测/"><script type="text/javascript" id="page.configurations">CONFIG.page={sidebar:""}</script><title>\[数字图像处理\]6.8:灰度图像-图像分割 Canny边缘检测 | 谭升的博客</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-105335860-3"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-105335860-3")</script><noscript><style type="text/css">.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">谭升的博客</span> <span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">人工智能基础</h1></div><div class="site-nav-toggle"><button aria-label="切换导航栏"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-首页"><a href="/" rel="section">首页</a></li><li class="menu-item menu-item-集合论"><a href="/categories/Mathematic/Set-Theory/" rel="section">集合论</a></li><li class="menu-item menu-item-线性代数"><a href="/categories/Mathematic/Linear-Algebra/" rel="section">线性代数</a></li><li class="menu-item menu-item-概率论"><a href="/categories/Mathematic/Probability/" rel="section">概率论</a></li><li class="menu-item menu-item-数理统计学"><a href="/categories/Mathematic/Statistics/" rel="section">数理统计学</a></li><li class="menu-item menu-item-数值分析"><a href="/categories/Mathematic/Numerical-Analysis/" rel="section">数值分析</a></li><li class="menu-item menu-item-机器学习算法"><a href="/categories/Machine-Learning/" rel="section">机器学习算法</a></li><li class="menu-item menu-item-强化学习"><a href="/categories/Reinforcement-Learning/" rel="section">强化学习</a></li><li class="menu-item menu-item-深度学习算法"><a href="/categories/Deep-Learning/" rel="section">深度学习算法</a></li><li class="menu-item menu-item-数字图像处理"><a href="/categories/DIP/" rel="section">数字图像处理</a></li><li class="menu-item menu-item-30天自制操作系统"><a href="/categories/30天自制操作系统/" rel="section">30天自制操作系统</a></li><li class="menu-item menu-item-cuda"><a href="/categories/CUDA/" rel="section">CUDA</a></li><li class="menu-item menu-item-网络爬虫"><a href="/categories/Crawler/" rel="section">网络爬虫</a></li><li class="menu-item menu-item-乱七八糟"><a href="/categories/Other/" rel="section">乱七八糟</a></li></ul></nav><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-1194454329688573" data-ad-slot="2491973880" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://www.face2ai.com/DIP-6-8-灰度图像-图像分割-Canny边缘检测/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="谭升"><meta itemprop="description" content="本站包括强化学习算法，机器学习算法，人工智能，CUDA编程，模式识别算法，线性代数，概率论，数理统计等人工智能原创博客"><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="谭升的博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">\[数字图像处理\]6.8:灰度图像-图像分割 Canny边缘检测</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2015-02-13 11:55:00" itemprop="dateCreated datePublished" datetime="2015-02-13T11:55:00+08:00">2015-02-13</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/DIP/" itemprop="url" rel="index"><span itemprop="name">DIP</span></a></span> </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> 阅读次数： <span class="busuanzi-value" id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body" itemprop="articleBody"><p><strong>Abstract:</strong> 数字图像处理：第46天<br><strong>Keywords:</strong> canny,边缘检测</p><a id="more"></a><p><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><br><ins class="adsbygoogle" style="display:block;text-align:center" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-1194454329688573" data-ad-slot="6331904368"></ins></p><p><script><br>     (adsbygoogle = window.adsbygoogle || []).push({});<br></script></p><p><font color="00FF00">本文最初发表于csdn，于2018年2月17日迁移至此</font></p><h1 id="灰度图像-图像分割-Canny边缘检测"><a href="#灰度图像-图像分割-Canny边缘检测" class="headerlink" title="灰度图像-图像分割 Canny边缘检测"></a>灰度图像-图像分割 Canny边缘检测</h1><p>废话开始，Canny大名鼎鼎，大家都称之为Canny算子，包括wiki上也是写的Canny detector，但是按照我的理解，我觉得叫做Canny算法比较合适，但如果叫做算子，那也应该叫做复合算子，因为Canny本身并不是一个线性模板（像Sobel那样）或者一个局部比较类的算法（像中值滤波那样的），Canny是一套完整的理论，并实现出了完整的算法。<br>Canny是目前已知的最好的边缘检测算法，是不是之一我不确定，但可以肯定的是，它的应用非常广泛，基本用到边缘检测的，大家永远第一个想到它。Canny算法的复杂度比前面的<strong>检测加阈值</strong>的算法计算复杂度更高，空间复杂度也要高一些，但现在的计算设备，对于Canny基本可以实现实时，并且有人用GPU来实现，所以从86年Canny提出了这个算法到现在，在边缘检测方面，其地位还是比较稳固的。<br>Canny算法的另一个显著特征是它有完整的数学推导过程，能够证明这个算法能给出最好的边缘。后面我们将会简单的看一下数学过程。</p><hr><h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>算法原理，Canny首先提出了三种基本条件，来定义一个边缘。来看原文[Canny1986]：</p><blockquote><p>1) Good detection. There should be a low probability of failing to mark real edge points, and low probability of falsely marking nonedge points. Since both these probabilities are monotonically decreasing functions of the output signal-to-noise ratio, this criterion corresponds to maximizing signal-to-noise ratio.<br>2) Good localization. The points marked as edge points by the operator should be as close as possible to the center of the true edge.<br>3) Only one response to a single edge. This is implicitly captured in the first criterion since when there are two responses to the same edge, one of them must be considered false. However, the mathematical form of the first criterion did not capture the multiple response requirement and it had to be made explicit.</p></blockquote><p>翻译一下：</p><ol><li>好的检测：一定要尽可能少的遗漏边缘点，尽可能少的添加非边缘点。正确的边缘点为信号，被错误检测出来的非边缘点为噪声，所以第一点归结为提高信噪比。</li><li>准确的位置：检测出的边缘点一定要与真正的边缘中心，尽可能的近。</li><li>边缘单一响应：对于一个边缘，只能产生一个响应，如果对于一个边缘产生两个响应，第一点的数学求解过程不能保证这一点，所以要单独明确，如果对于一边有两个响应，必须去掉一个。</li></ol><p>这就是Canny的指导思想，并且根据这一思想进行建模。</p><hr><h2 id="数学原理"><a href="#数学原理" class="headerlink" title="数学原理"></a>数学原理</h2><p>发表在VOL. PAMI-8, NO. 6, NOVEMBER 1986上的文章给出了明确的求解过程，包括建模上面的理论，并求解最优解，因为本人数学功底一般，后面的求解过程有兴趣的同学可以自行查看论文，这里只给出建模上面三个基本原理的过程，以一维下的情况给出。<br>首先我们设滤波器的单位冲击响应为： $f(x)$ ，定义边缘本身为 $G(x)$ ，边缘中心位置为$x=0$处，滤波器响应范围 $[-w,+w]$<br>边缘对滤波器的响应为：<br>$H_G(x)=\int_{-w}^{+w} G(-x)f(x)\,dx$ (1)</p><p>噪声 $n(x)$ 相应的均方根为：<br>$H_n=n_0[\int_{-w}^{+w}f^2(x)\,dx]^{1/2}$ (2)</p><p>其中 $n^2_0$ 是单位长度的均方噪声幅度<br>由上面两个式子，我们定义信噪比SNR：<br>$SNR=\frac{\int_{-w}^{+w} G(-x)f(x)\,dx}{n_0[\int_{-w}^{+w}f^2(x)\,dx]^{1/2}}$ (3)</p><p>这便是原理1的建模，使信噪比尽可能大，来满足原理1。<br>为了度量检测出的边缘与实际边缘的位置关系，我们使用均方根误差距离。对于检测滤波器 $f(x)$ 我们一般认为滤波结果给出的局部最大值为检测到的边缘，所以如果没有噪声加入时响应结果的一阶导数在$x=0$处应该为0，即 $x=0$ 为对滤波器响应的局部最大值，也就是计算边界点。<br>设 $H_n(x)$ 只是噪声对滤波器的响应， $H_G(x)$ 只是边缘对滤波器的响应，根据上面的设想，一定有 $x=x_0$ 处满足：</p><p>$H^{‘}_n(x_0)+H^{‘}_G(x_0)=0$ (4)</p><p>泰勒展开 $H^{‘}_G(x_0)$ 可以得出：</p><p>$H^{‘}_G(x_0)=H^{‘}_G(0)+H^{‘’}_G(0)x_0+o(x_0^2)$ (5)</p><p>因为可以确定 $H^{‘}_G(0)=0$ 结合(4)(5)可以得出：</p><p>$H^{‘’}_G(0)x_0 \approx {-H^{‘}_n(x_0)}$(6)</p><p>$H^{‘}_n(x_0)$ 为高斯随机量，并且其方差是 $H^{‘}_n(x_0)$ 的均方值，并且给出其期望为：</p><p>$E[H^{‘}_n(x_0)^2]=n_0^2\int^{+w}_{-w}f^{‘2}(x)\,dx$(7)</p><p>将(7)和(6)结合，可以得到：</p><p>$E[x^2_0]\approx {\frac{n_0^2\int^{+w}_{-w}f^{‘2}(x)\,dx}{[{\int_{-w}^{+w} G^{‘}(-x)f^{‘}(x)\,dx}]^2}}=\delta x^2_0$ (8)</p><p>$\delta x^2_0$ 是 $x_0$ 标准差的近似，位置由其倒数给出：</p><p>$Localization =\frac{|\int^{+w}_{-w}G^{‘}(-x)f^{‘}(x)\,dx|}{n_0[\int^{+w}_{-w}f^{‘2}(x)\,dx]^{-1/2}}$(9)</p><p>这便是原理2的建模，使信噪比尽可能大，来满足原理1。<br>结合原理1，原理2，我们得出为了满足前面两个基本原理，需要最大化：</p><p>$\frac{\int_{-w}^{+w} G(-x)f(x)\,dx}{n_0[\int_{-w}^{+w}f^2(x)\,dx]^{1/2}}\frac{|\int^{+w}_{-w}G^{‘}(-x)f^{‘}(x)\,dx|}{n_0[\int^{+w}_{-w}f^{‘2}(x)\,dx]^{-1/2}}$(10)</p><p>下面就是第三个原理的过程了，其与前两个原理使用的只是不太相同，根据Schwarz不等式，SNR（3）中给出的式子上边界为：</p><p>$n^{-1}_0[\int^{+w}_{-w}G^{2}(x)dx]^{1/2}$</p><p>Localization(9)上边界于：</p><p>$n^{-1}_0[\int^{+w}_{-w}G’^{2}(x)dx]^{1/2}$</p><p>最大值出现在 $f(x)=G(-x)$ 其中 $x$ 属于 $[-w,+w]$<br>检测点到真实点的平均距离为：</p><p>$x_{ave}=\pi(\frac{-R(0)}{R^{‘’}(0)})^{1/2}$(11)</p><p>其中R是函数g的自相关：</p><p>$R(0) = \int ^{+\infty}_{-\infty}g^{2}(x)\,dx$</p><p>$R^{‘’}(0) = -\int ^{+\infty}_{-\infty}{g’}^{2}(x)\,dx$</p><p>所以 $f’$ 的零交叉平均距离为：</p><p>$x_{zc}(f)=\pi(\frac{\int ^{+\infty}_{-\infty}f’^{2}(x)\,dx}{\int ^{+\infty}_{-\infty}{f’’}^{2}(x)\,dx})^{1/2}$(12)</p><p>对于 $f$ 的最大噪声响应 $x_{max}$ 定义为两倍 $x_{zc}$ 我们定义其为滤波器宽度的k倍</p><p>$x_{max}(f)=2x_{zc}(f)=kW$(13)</p><p>所以噪声最大的数量在 $N_n$ 区域内：</p><p>$N_n=\frac{2W}{x_{max}}=\frac{2}{k}$(14)</p><h2 id="数学建模大概如上，可能看不懂，但是没关系，因为这并不影响我们对算法过程的理解。"><a href="#数学建模大概如上，可能看不懂，但是没关系，因为这并不影响我们对算法过程的理解。" class="headerlink" title="数学建模大概如上，可能看不懂，但是没关系，因为这并不影响我们对算法过程的理解。"></a>数学建模大概如上，可能看不懂，但是没关系，因为这并不影响我们对算法过程的理解。</h2><h2 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h2><p>算法过程比较容易：</p><ol><li>高斯平滑，采用$5 \times5$的高斯滤波器对图像进行平滑。</li><li>使用Sobel算子检测边缘候选点，计算梯度方向，得到简化的梯度方向。</li><li>非极大值抑制，减少多重响应。</li><li>边缘跟踪，采用双阈值处理候选点。</li><li>形态学细化，对于有些较粗的边界采用形态学方法处理。</li></ol><p>具体解析：<br>第一步：高斯平滑，Canny的核心检测算子是Sobel算子，所以。Canny如果按照算子划分的话属于一阶微分算子，所以它具有一阶微分算子的特性，对噪声敏感，所以，我们的第一步就是降低噪声，使用高斯平滑降低噪声，冈萨雷斯书上介绍说Canny证明高斯平滑是最好的平滑算子，这一点我并未查证，但根据高斯函数的频域特性可知，它没有振铃，而且当频率值超过 $3\times \delta$ 时基本趋近于零，所以可以当做一种完美的滤波器（以上这句话是我猜测的，没有理论根据），此步骤的主要目的–降噪<br>第二步：Sobel边缘检测，此处为检测边缘候选点，并计算出候选点梯度的过程，其中Sobel可选大小为3x3，5x5，7x7或者-1，其中-1表示为Scharr算子，这个在前文已经比较过了Sobel和Scharr的性能，在这里不再解释<br>第三步：局部非极大值抑制，俗话就是找局部最大值，寻找方法是得出每个候选点的梯度方向，沿着梯度方向和梯度反方向比较相邻的元素，如果候选点是三个中最大的，则保留，否则，置零。<br>第四步：双阈值滞后滤波，这里的滞后滤波应该是比较难以理解的，我们分别设置两个阈值，大阈值和小阈值之间比例大于为3：1或2：1，这里的方法是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 输入候选点灰度值</span><br><span class="line">2. 判断是否大于大阈值，如果大于则到第4步</span><br><span class="line">2. 判断是否大于小阈值，如果小于则到第5步</span><br><span class="line">3. 判断该点是否连通于边缘点，不是则到第5步</span><br><span class="line">4. 此点为边缘点，到第6步</span><br><span class="line">5. 此点非边缘点</span><br><span class="line">6. 如果图像还有未处理候选边缘像素，返回第1步，否则结束</span><br></pre></td></tr></table></figure><p>双阈值滞后处理是Canny的核心部分，下面给出双阈值的阈值传递函数：<br><img src="https://tony4ai-1251394096.cos.ap-hongkong.myqcloud.com/blog_images/DIP-6-8-灰度图像-图像分割-Canny边缘检测/20150212181022310.jpeg" alt=""></p><p>上图说明只有的时滞后阈值的传递函数，解释下就是如果一个候选点大于高阈值，那么它肯定是边缘点，如果大于小阈值，则需要它连通到边缘点。<br>我们在算法实现时使用方法是，先找到所有大于大阈值的点的集合H，H全部为边缘点，然后找出所有大于小阈值的点的集合L，其中L包含所有的H，那么以H中的每个点为种子点，以八邻域遍历L，被遍历到的为边缘点，未被遍历的为非边缘点。这里的遍历与图的遍历相同，可以使用深度优先或广度优先。</p><p>第五步：细化结果，有时一个边缘会产生两个等价的边缘点，使用细化可以得到单像素边缘，但需注意，这两个点都是正确的点，选其中任意一个都是正确的。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *   四个角度对应编号</span></span><br><span class="line"><span class="comment"> *   0 1 2</span></span><br><span class="line"><span class="comment"> *   3 * 5</span></span><br><span class="line"><span class="comment"> *   6 7 8</span></span><br><span class="line"><span class="comment"> *   edgedirction</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getEdgeDirection</span><span class="params">(<span class="keyword">double</span> *edgedirection,<span class="keyword">double</span> *sample_direction,<span class="keyword">int</span> width,<span class="keyword">int</span> height)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> angle=<span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;width*height;i++)&#123;</span><br><span class="line">        angle=edgedirection[i];</span><br><span class="line">        <span class="keyword">if</span>(angle&lt;<span class="number">22.5</span>||angle&gt;=<span class="number">337.5</span>)</span><br><span class="line">            sample_direction[i]=<span class="number">5.0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(angle&lt;<span class="number">67.5</span>&amp;&amp;angle&gt;=<span class="number">22.5</span>)</span><br><span class="line">            sample_direction[i]=<span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(angle&lt;<span class="number">112.5</span>&amp;&amp;angle&gt;=<span class="number">67.5</span>)</span><br><span class="line">            sample_direction[i]=<span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(angle&lt;<span class="number">157.5</span>&amp;&amp;angle&gt;=<span class="number">112.5</span>)</span><br><span class="line">            sample_direction[i]=<span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(angle&lt;<span class="number">202.5</span>&amp;&amp;angle&gt;=<span class="number">157.5</span>)</span><br><span class="line">            sample_direction[i]=<span class="number">3.0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(angle&lt;<span class="number">247.5</span>&amp;&amp;angle&gt;=<span class="number">202.5</span>)</span><br><span class="line">            sample_direction[i]=<span class="number">6.0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(angle&lt;<span class="number">292.5</span>&amp;&amp;angle&gt;=<span class="number">247.5</span>)</span><br><span class="line">            sample_direction[i]=<span class="number">7.0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(angle&lt;<span class="number">337.5</span>&amp;&amp;angle&gt;=<span class="number">292.5</span>)</span><br><span class="line">            sample_direction[i]=<span class="number">8.0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(angle==<span class="number">-1.0</span>)</span><br><span class="line">            sample_direction[i]=<span class="number">-1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *   四个角度对应编号</span></span><br><span class="line"><span class="comment"> *   0 1 2</span></span><br><span class="line"><span class="comment"> *   3 * 5</span></span><br><span class="line"><span class="comment"> *   6 7 8</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Non_MaxSuppression</span><span class="params">(<span class="keyword">double</span> *src,<span class="keyword">double</span> *dst,<span class="keyword">double</span> *dirction,<span class="keyword">int</span> width,<span class="keyword">int</span> height)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> *temp=(<span class="keyword">double</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">double</span>)*width*height);</span><br><span class="line">    <span class="keyword">int</span> dir;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">double</span> value_c;</span><br><span class="line">    Zero(temp, width, height);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;height<span class="number">-1</span>;j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;width<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dirction[j*width+i]!=<span class="number">-1.0</span>)&#123;</span><br><span class="line">                dir=(<span class="keyword">int</span>)dirction[j*width+i];</span><br><span class="line">                y=dir/<span class="number">3</span><span class="number">-1</span>;</span><br><span class="line">                x=dir%<span class="number">3</span><span class="number">-1</span>;</span><br><span class="line">                value_c=src[j*width+i];</span><br><span class="line">                <span class="keyword">if</span>(value_c&lt;=src[(j+y)*width+i+x]||value_c&lt;src[(j-y)*width+i-x])</span><br><span class="line">                    temp[j*width+i]=<span class="number">0.0</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    temp[j*width+i]=value_c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    matrixCopy(temp, dst, width, height);</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EdgeTrack</span><span class="params">(<span class="keyword">double</span> *src,<span class="keyword">int</span> width,<span class="keyword">int</span> height,Position *seed)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=seed-&gt;x;</span><br><span class="line">    <span class="keyword">int</span> y=seed-&gt;y;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;width&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;height&amp;&amp;src[y*width+x]==<span class="number">1.0</span>)&#123;</span><br><span class="line">        src[y*width+x]=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">-1</span>;j&lt;<span class="number">2</span>;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">-1</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!(j==<span class="number">0</span>&amp;&amp;i==<span class="number">0</span>))&#123;</span><br><span class="line">                    Position seed_next;</span><br><span class="line">                    seed_next.x=x+i;</span><br><span class="line">                    seed_next.y=y+j;</span><br><span class="line">                    EdgeTrack(src,width,height,&amp;seed_next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NonZeroSetOne</span><span class="params">(<span class="keyword">double</span> *src,<span class="keyword">double</span> *dst,<span class="keyword">int</span> width,<span class="keyword">int</span> height)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;width*height;i++)</span><br><span class="line">        dst[i]=src[i]!=<span class="number">0.0</span>?<span class="number">1.0</span>:<span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Canny</span><span class="params">(<span class="keyword">double</span> *src,<span class="keyword">double</span> *dst,<span class="keyword">int</span> width,<span class="keyword">int</span> height,<span class="keyword">int</span> sobel_size,<span class="keyword">double</span> threshold1,<span class="keyword">double</span> threshold2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> *temp=(<span class="keyword">double</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">double</span>)*width*height);</span><br><span class="line">    <span class="keyword">double</span> *edge_a=(<span class="keyword">double</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">double</span>)*width*height);<span class="comment">//边缘幅度</span></span><br><span class="line">    <span class="keyword">double</span> *edge_d=(<span class="keyword">double</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">double</span>)*width*height);<span class="comment">//边缘方向</span></span><br><span class="line">    <span class="keyword">double</span> *threshold_max=(<span class="keyword">double</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">double</span>)*width*height);</span><br><span class="line">    <span class="keyword">double</span> *threshold_min=(<span class="keyword">double</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">double</span>)*width*height);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *step1:gaussian smooth</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">double</span> gaussianmask[<span class="number">25</span>]=&#123; <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>,</span><br><span class="line">                              <span class="number">4</span>, <span class="number">9</span>,<span class="number">12</span>, <span class="number">9</span>, <span class="number">4</span>,</span><br><span class="line">                              <span class="number">5</span>,<span class="number">12</span>,<span class="number">15</span>,<span class="number">12</span>, <span class="number">5</span>,</span><br><span class="line">                              <span class="number">4</span>, <span class="number">9</span>,<span class="number">12</span>, <span class="number">9</span>, <span class="number">4</span>,</span><br><span class="line">                              <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    RealConvolution(src, temp, gaussianmask, width, height, <span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line">    matrixMultreal(temp, temp, <span class="number">1.0</span>/<span class="number">159.0</span>, width, height);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *step2:sobel</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">if</span>(sobel_size==<span class="number">3</span>)</span><br><span class="line">        Scharr(temp, edge_a, edge_d, width, height);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(sobel_size==<span class="number">5</span>||sobel_size==<span class="number">7</span>)</span><br><span class="line">        Sobel(temp, edge_a, edge_d, width, height,sobel_size);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *step3:Non_MaxSuppression</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    getEdgeDirection(edge_d, edge_d, width, height);</span><br><span class="line">    Non_MaxSuppression(edge_a, temp, edge_d, width, height);</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> *step4:double threshold</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    Threshold(temp, threshold_max, width, height, threshold1, MORETHAN);</span><br><span class="line">    Threshold(temp, threshold_min, width, height, threshold2, MORETHAN);</span><br><span class="line">    NonZeroSetOne(threshold_max,threshold_max,width,height);</span><br><span class="line">    NonZeroSetOne(threshold_min,threshold_min,width,height);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;height;j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;width;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(threshold_max[j*width+i]==<span class="number">1.0</span>&amp;&amp;threshold_min[j*width+i]!=<span class="number">2.0</span>)&#123;</span><br><span class="line">                Position p;</span><br><span class="line">                p.x=i;</span><br><span class="line">                p.y=j;</span><br><span class="line">                EdgeTrack(threshold_min, width, height, &amp;p);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *step5:result</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    Zero(dst, width, height);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;width*height;i++)</span><br><span class="line">        <span class="keyword">if</span>(threshold_min[i]==<span class="number">2.0</span>)</span><br><span class="line">            dst[i]=<span class="number">255.0</span>;</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    <span class="built_in">free</span>(threshold_max);</span><br><span class="line">    <span class="built_in">free</span>(threshold_min);</span><br><span class="line">    <span class="built_in">free</span>(edge_d);</span><br><span class="line">    <span class="built_in">free</span>(edge_a);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现结果"><a href="#实现结果" class="headerlink" title="实现结果"></a>实现结果</h2><p>实验每步结果：<br>原图：<br><img src="https://tony4ai-1251394096.cos.ap-hongkong.myqcloud.com/blog_images/DIP-6-8-灰度图像-图像分割-Canny边缘检测/20150212181924413.jpeg" alt=""></p><p>STEP1：<br><img src="https://tony4ai-1251394096.cos.ap-hongkong.myqcloud.com/blog_images/DIP-6-8-灰度图像-图像分割-Canny边缘检测/20150212181937158.jpeg" alt=""></p><p>STEP2：<br>Sobel梯度幅度结果：<br><img src="https://tony4ai-1251394096.cos.ap-hongkong.myqcloud.com/blog_images/DIP-6-8-灰度图像-图像分割-Canny边缘检测/20150212181953180.jpeg" alt=""></p><p>Sobel梯度方向结果：<br><img src="https://tony4ai-1251394096.cos.ap-hongkong.myqcloud.com/blog_images/DIP-6-8-灰度图像-图像分割-Canny边缘检测/20150212182006783.jpeg" alt=""></p><p>STEP3：<br><img src="https://tony4ai-1251394096.cos.ap-hongkong.myqcloud.com/blog_images/DIP-6-8-灰度图像-图像分割-Canny边缘检测/20150212182025625.jpeg" alt=""></p><p>STEP4：<br><img src="https://tony4ai-1251394096.cos.ap-hongkong.myqcloud.com/blog_images/DIP-6-8-灰度图像-图像分割-Canny边缘检测/20150212182315899.jpeg" alt=""></p><hr><p>原图：<br><img src="https://tony4ai-1251394096.cos.ap-hongkong.myqcloud.com/blog_images/DIP-6-8-灰度图像-图像分割-Canny边缘检测/20150212182333621.jpeg" alt=""></p><p>STEP1：<br><img src="https://tony4ai-1251394096.cos.ap-hongkong.myqcloud.com/blog_images/DIP-6-8-灰度图像-图像分割-Canny边缘检测/20150212182345025.jpeg" alt=""></p><p>STEP2：<br>Sobel梯度幅度结果：</p><p><img src="https://tony4ai-1251394096.cos.ap-hongkong.myqcloud.com/blog_images/DIP-6-8-灰度图像-图像分割-Canny边缘检测/20150212182356134.jpeg" alt=""></p><p>Sobel梯度方向结果：<br><img src="https://tony4ai-1251394096.cos.ap-hongkong.myqcloud.com/blog_images/DIP-6-8-灰度图像-图像分割-Canny边缘检测/20150212182416318.jpeg" alt=""></p><p>STEP3：<br><img src="https://tony4ai-1251394096.cos.ap-hongkong.myqcloud.com/blog_images/DIP-6-8-灰度图像-图像分割-Canny边缘检测/20150212182426040.jpeg" alt=""></p><p>STEP4：<br><img src="https://tony4ai-1251394096.cos.ap-hongkong.myqcloud.com/blog_images/DIP-6-8-灰度图像-图像分割-Canny边缘检测/20150212182449655.jpeg" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结，Canny实现起来算法过程并不难，可能进一步优化加速就需要一些难度了，冈萨雷斯书中提到，第四步滞后阈值可以和第三步非极大值抑制放在一起。<br>待续。。。。</p><p>原文地址1：<a href="https://www.face2ai.com/DIP-6-8-灰度图像-图像分割-Canny边缘检测">https://www.face2ai.com/DIP-6-8-灰度图像-图像分割-Canny边缘检测</a>转载请标明出处</p></div><div><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div>关注公众号或添加博主微信，反馈问题，获取资讯（暗号:face2ai）</div><button id="rewardButton" disable="enable" onclick='var qr=document.getElementById("QR");"none"===qr.style.display?qr.style.display="block":qr.style.display="none"'><span>联系博主</span></button><div id="QR" style="display:none"><div id="wechat" style="display:inline-block"><img id="wechat_qr" src="/images/weixin.png" alt="谭升 博主微信"><p>博主微信</p></div><div id="alipay" style="display:inline-block"><img id="alipay_qr" src="/images/alipay.jpg" alt="谭升 博客公众号"><p>博客公众号</p></div></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>谭升</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="http://www.face2ai.com/DIP-6-8-灰度图像-图像分割-Canny边缘检测/" title="\[数字图像处理\]6.8:灰度图像-图像分割 Canny边缘检测">http://www.face2ai.com/DIP-6-8-灰度图像-图像分割-Canny边缘检测/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/DIP-6-7-灰度图像-图像分割-算子平滑能力比较/" rel="next" title="\[数字图像处理\]6.7:灰度图像-图像分割 Sobel算子，Prewitt算子和Scharr算子平滑能力比较"><i class="fa fa-chevron-left"></i> \[数字图像处理\]6.7:灰度图像-图像分割 Sobel算子，Prewitt算子和Scharr算子平滑能力比较</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/DIP-6-9-灰度图像-图像分割-Marr-Hildreth算子-LoG算子/" rel="prev" title="\[数字图像处理\]6.9:灰度图像-图像分割 Marr-Hildreth算子（LoG算子）">\[数字图像处理\]6.9:灰度图像-图像分割 Marr-Hildreth算子（LoG算子） <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article></div><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-1194454329688573" data-ad-slot="2491973880" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div id="sidebar-dimmer"></div><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="谭升"><p class="site-author-name" itemprop="name">谭升</p><p class="site-description motion-element" itemprop="description">本站包括强化学习算法，机器学习算法，人工智能，CUDA编程，模式识别算法，线性代数，概率论，数理统计等人工智能原创博客</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives"><span class="site-state-item-count">261</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">20</span> <span class="site-state-item-name">分类</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/tony-tan" target="_blank" title="GitHub" rel="external nofollow"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:tony.face2ai@gmail.com" target="_blank" title="E-Mail" rel="external nofollow"><i class="fa fa-fw fa-envelope"></i>E-Mail</a> </span><span class="links-of-author-item"><a href="https://twitter.com/Tony_Face2AI" target="_blank" title="Twitter" rel="external nofollow"><i class="fa fa-fw fa-twitter"></i>Twitter</a></span></div><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-1194454329688573" data-ad-slot="9135658886" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#灰度图像-图像分割-Canny边缘检测"><span class="nav-number">1.</span> <span class="nav-text">灰度图像-图像分割 Canny边缘检测</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#算法原理"><span class="nav-number">1.1.</span> <span class="nav-text">算法原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数学原理"><span class="nav-number">1.2.</span> <span class="nav-text">数学原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数学建模大概如上，可能看不懂，但是没关系，因为这并不影响我们对算法过程的理解。"><span class="nav-number">1.3.</span> <span class="nav-text">数学建模大概如上，可能看不懂，但是没关系，因为这并不影响我们对算法过程的理解。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法过程"><span class="nav-number">1.4.</span> <span class="nav-text">算法过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#代码实现"><span class="nav-number">1.5.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现结果"><span class="nav-number">1.6.</span> <span class="nav-text">实现结果</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">1.7.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2018</span> <span class="with-love" id="animate"><i class="fa fa-"></i> </span><span class="author" itemprop="copyrightHolder">谭升</span></div><div class="busuanzi-count"><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="site-uv" title="总访客量"><i class="fa fa-user"></i> <span class="busuanzi-value" id="busuanzi_value_site_uv"></span> </span><span class="site-pv" title="总访问量"><i class="fa fa-eye"></i> <span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/js/src/utils.js?v=6.4.0"></script><script type="text/javascript" src="/js/src/motion.js?v=6.4.0"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=6.4.0"></script><script type="text/javascript" src="/js/src/post-details.js?v=6.4.0"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.0"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      },
      TeX: {equationNumbers: { autoNumber: "AMS" }}
    });</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });</script><script type="text/javascript" src="//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>