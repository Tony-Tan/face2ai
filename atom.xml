<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>谭升的博客</title>
  
  <subtitle>人工智能基础</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.face2ai.com/"/>
  <updated>2018-12-29T02:16:20.199Z</updated>
  <id>http://www.face2ai.com/</id>
  
  <author>
    <name>谭升</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【线性代数视频课程】 试讲 -- 第三课 矩阵的来历</title>
    <link href="http://www.face2ai.com/Math-Linear-Algebra-video-class-3/"/>
    <id>http://www.face2ai.com/Math-Linear-Algebra-video-class-3/</id>
    <published>2018-12-29T01:57:47.000Z</published>
    <updated>2018-12-29T02:16:20.199Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Abstract:</strong> 本视频介绍矩阵的来历<br><strong>Keywords:</strong> 线性代数视频课程<br><a id="more"></a></p><p><iframe frameborder="0" height="480" width="640" src="https://v.qq.com/txp/iframe/player.html?vid=m08202djwk9" allowfullscreen="true"></iframe><br>意见和建议请大家留言或者微信反馈，完整系列将在稍后推出</p><hr><p>原文地址: <a href="https://face2ai.com/Math-Linear-Algebra-video-class-3" target="_blank" rel="noopener">https://face2ai.com/Math-Linear-Algebra-video-class-3</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; 本视频介绍矩阵的来历&lt;br&gt;&lt;strong&gt;Keywords:&lt;/strong&gt; 线性代数视频课程&lt;br&gt;
    
    </summary>
    
      <category term="Mathematic" scheme="http://www.face2ai.com/categories/Mathematic/"/>
    
      <category term="Linear Algebra" scheme="http://www.face2ai.com/categories/Mathematic/Linear-Algebra/"/>
    
    
      <category term="线性代数视频课程" scheme="http://www.face2ai.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E8%A7%86%E9%A2%91%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>【线性代数视频课程】 试讲 -- 第二课 向量知识回顾</title>
    <link href="http://www.face2ai.com/Math-Linear-Algebra-video-class-2/"/>
    <id>http://www.face2ai.com/Math-Linear-Algebra-video-class-2/</id>
    <published>2018-12-29T01:56:18.000Z</published>
    <updated>2018-12-29T02:16:21.473Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Abstract:</strong> 线性代数视频课程第二节，向量知识回顾<br><strong>Keywords:</strong> 线性代数视频课程<br><a id="more"></a></p><iframe frameborder="0" height="480" width="640" src="https://v.qq.com/txp/iframe/player.html?vid=o0819ne053u" allowfullscreen="true"></iframe><p>意见和建议请大家留言或者微信反馈，完整系列将在稍后推出</p><hr><p>原文地址: <a href="https://face2ai.com/Math-Linear-Algebra-video-class-2" target="_blank" rel="noopener">https://face2ai.com/Math-Linear-Algebra-video-class-2</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; 线性代数视频课程第二节，向量知识回顾&lt;br&gt;&lt;strong&gt;Keywords:&lt;/strong&gt; 线性代数视频课程&lt;br&gt;
    
    </summary>
    
      <category term="Mathematic" scheme="http://www.face2ai.com/categories/Mathematic/"/>
    
      <category term="Linear Algebra" scheme="http://www.face2ai.com/categories/Mathematic/Linear-Algebra/"/>
    
    
      <category term="线性代数视频课程" scheme="http://www.face2ai.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E8%A7%86%E9%A2%91%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>【线性代数视频课程】 试讲 -- 第一课 简介</title>
    <link href="http://www.face2ai.com/Math-Linear-Algebra-video-class-1/"/>
    <id>http://www.face2ai.com/Math-Linear-Algebra-video-class-1/</id>
    <published>2018-12-29T01:40:54.000Z</published>
    <updated>2018-12-29T02:16:22.384Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Abstract:</strong> 线性代数视频课程第一节，简介<br><strong>Keywords:</strong> 线性代数视频课程<br><a id="more"></a></p><p><iframe frameborder="0" height="480" width="640" src="https://v.qq.com/txp/iframe/player.html?vid=h0817d5z7qi" allowfullscreen="true"></iframe><br>意见和建议请大家留言或者微信反馈，完整系列将在稍后推出</p><hr><p>原文地址: <a href="https://face2ai.com/Math-Linear-Algebra-video-class-1" target="_blank" rel="noopener">https://face2ai.com/Math-Linear-Algebra-video-class-1</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; 线性代数视频课程第一节，简介&lt;br&gt;&lt;strong&gt;Keywords:&lt;/strong&gt; 线性代数视频课程&lt;br&gt;
    
    </summary>
    
      <category term="Mathematic" scheme="http://www.face2ai.com/categories/Mathematic/"/>
    
      <category term="Linear Algebra" scheme="http://www.face2ai.com/categories/Mathematic/Linear-Algebra/"/>
    
    
      <category term="线性代数视频课程" scheme="http://www.face2ai.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E8%A7%86%E9%A2%91%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>一封来自读者的信</title>
    <link href="http://www.face2ai.com/Other-a-mail/"/>
    <id>http://www.face2ai.com/Other-a-mail/</id>
    <published>2018-11-24T03:26:33.000Z</published>
    <updated>2018-11-24T03:50:26.539Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Abstract:</strong> 一封来自读者的信<br><strong>Keywords:</strong> 计算机视觉，就业，人工智能，深度学习<br><a id="more"></a><br>收到一位读者的来信，字里行间都看到了当年的自己，中间有一些问题觉得很多人可能都有，所以在他同意的情况下，我把邮件部分贴出来，希望能帮助更多的人。<br><img src="https://tony4ai-1251394096.cos.ap-hongkong.myqcloud.com/blog_images/Other-a-mail/chat.jpeg" alt=""><br><img src="https://tony4ai-1251394096.cos.ap-hongkong.myqcloud.com/blog_images/Other-a-mail/mail1.png" alt=""><br><img src="https://tony4ai-1251394096.cos.ap-hongkong.myqcloud.com/blog_images/Other-a-mail/mail2.png" alt=""><br>原文：</p><blockquote><p>同学，您好：<br>很高兴收到的微信咨询，本来想在微信上回复你，但是我觉得还是好好思考一下你的问题然后把这些问题大概总结一下，回复给你可能更准确也更有帮助，另外我觉得有你这些问题的人应该不少，所以，如果你同意我会在博客上公开这封回信和我们的部分聊天记录，当然我会隐藏掉所有您的个人信息。<br>看我的博客的很多人都是在校的学生，包括一些本科的同学以及硕士博士研究生，其中我感觉硕士居多，很不幸，我个人是没有读过硕士的，所以对大部分硕士课程以及硕士工作没有什么了解，当然我更不能深入了解每个课题组的深入程度。<br>我收到的询问一般都是一些入门级的同学发给我的，这很正常，入门之前会恐慌迷茫不知所措，所以需要询问；一旦入门了，需要的工作就是调整，深入了，即使是讨论，也不会找我这种江湖野怪，所以我无法了解到那些人，所以本文不适合那些已经入门的人。<br>下面来回答你的问题：</p><ol><li>你首先介绍了一下你目前的情况，985，研一，老师是做机器视觉，机械部分，视觉机器人，困惑是自己不知道选什么方向</li><li>实验室别人是做什么的，有人做深度学习，有人做后端，有人做视觉检测</li><li>你的问题是你要不要跟着师兄们的脚步还是跟着老师的脚步做机械部分</li><li>就业形势，深度学习以后的发展，自己非科班，转机器视觉是因为机械行业不景气。<br>下面是我个人的对你目前状况的理解，和一些个人的建议，仅供你参考。对于任何问题每个人都有不同看法，有人务实可能选择走保守道路，有人理想，选择走一些理想化的路线，我肯定也会有自己的态度，而对你来说，我的态度对你来说就是一种噪音，或者更准确说，就是误导，所以，你可以多听几个人的建议，综合来看。你听邻居大婶的意见，还不如自己做决定。</li><li>985，这个数字是在校学生表示自己身份的象征，在学校其间，能证明我们能力的只有学校好坏，而到了社会能证明我们身份的就是变成，车，房子，衣着等，其实我不认为985就有多好，我也不会看不起三本的学生，因为有些985的学生最后干的事，如果从社会的角度还不如我们村种菜的大爷对社会的贡献大。我们的社会文化导致了我们从出生开始就要被比较那些能看到的东西，身高，长相，小学考第几，初中考第几，上的什么高中什么大学，这些都是挂在表面的东西，而这个现象的结果是导致我们自己也开始只追求外在的东西，所以对于985，我给你的建议是，如果你内心足够强大，可以完全不顾及外在的东西，深入修炼自己的内心（包括对事物的理解，基础知识，比如数学，语言，编程这些基础的知识技术，过程很苦，看不到什么提高，但是我认为是非常有用的）。老师做的自己不喜欢，或者就业形势不好：我知道很多人不知道自己喜欢什么，或者自己喜欢的东西不能被用来谋生（唱歌跳舞什么的），首先我觉得这个问题我之前也遇到过，最求喜欢的还是追求活下来，如果你的爱好不能够支持你的生活，我建议把80%的精力放在你的谋生技能上，也就是说你的谋生技能要在行业平均水平之上，至于做什么，你可以自己找一个自己相关的，又不太讨厌的做，而你真正的爱好，只有你自己知道的那个，你可以用业余的时间来继续，提高水平同时能够体会到快乐。如果你既不知道自己喜欢什么，也不知道做什么事会开心，我觉得你应该继续找到这件事，如果找不到，这会是个悲剧。自己选方向：工作方向，与目前已经掌握的技能相关，且自己能够掌控的，行业我会在后面说。</li><li>实验室里的人都在做别的，自己要不要学：不能别人干什么你就觉得那个好，从众可以用来保护自己，但是不能作为自己奋斗目标，每个人的性格和技能基础都不同，所以他们做的事可能不一定适合你，像1中说的，你可以80%的精力用于你以后的事业，20%用于爱好。IT行业的细分很多，也很细，所以找一个自己不太讨厌的其实不难，不要担心这个行业怎么样，关键是你的目标是学一点然后找个公司混日子，还是说把这个干好，如果你能把某项技能掌握的很好的话，找工作谋生一般没问题，当然技术最好是主流或者有一定前景的，传呼机维修这种技术就是一个反面典型（来自郭德纲的段子）。</li><li>这和2中的回答一样，不要只看试验是的几个人是做什么的，多在网上看看最新的东西，如果可以，多去Youtube上逛逛是好的，你们村的集市的视野是不如世博会的，找几个自己喜欢的，好好调查一下。导师和师兄在很多人看来就是权威了，当然，实验室环境是，但是这些权威其实没有你看得那么权威，我们从小就喜欢跟随权威，比如有人也把我当成权威，说实话，这些权威包括我就是普通人，而权威的见解就是他们的个人见解，有些很片面，有些甚至就是不对的，所以你不需要100%的跟随他们。</li><li>就业形势不好，因为经济不好，宏观经济以及行业环境都不太好，所以我觉得你要做的更应该是提高自己的技能，求值就是个求期望的过程，要为了得到大的期望，你能做的就是提高自己的概率，也就是让自己在专业方面变得更强大一些，而不是找一个行业招人多的，后者想法会让人一直堕落下去。非科班的问题是基础不好，所以你要做得的是补充自己的基础，深度学习（调参）以后没什么发展，这是我说的，我不是权威，但是研究其工作原理会有前途，但是我们目前的应用主要工作是调参，没人会花钱请你去研究模型的数学原理（Google这些公司除外，我说的是中国公司）人工智能未来会是个非常强的方向，但是不一定是深度学习。计算机视觉，机械这些行业都是强应用行业，机械我不懂，但是计算机视觉我觉得应该是好方向，但是目前国内的水平一般，因为计算机视觉的一个主要特征是替代人类，完成重复工作，而我国目前最不缺的就是人，所以计算机视觉的最近几年的招聘情况我不知道，如果计算机视觉的需求量大的话，这是个非常不错的行业，我理解机械也是个非常有前景的行业，只是热度目前不如人工智能类的这些工作。<br>希望能帮助你，注意，我的这些都是给你提供信息，而不是强烈建议或者指导，没有一个人的思想能指导别人的行为，只是提供信息，希望你多思考，多浏览，<br>Tony<br>Nov,24,2018</li></ol></blockquote><p>收到的回信原文：</p><blockquote><p>谭老师，您好<br> 多谢老师抽出时间为我指点迷津，正像老师所说的，我应该首先对自己有个清晰的认识，然后再选择自己的发展方向。<br> 现在的社会是资产财富论能力，然而大学入学时大家都差不多，不同的专业进入社会开始拉开差距，生化环材也正是因为这个原因被称为劝退专业，机械则是屌丝专业，个人觉得这些专业的学生并不比CS EE 差，但是赚不到钱的就得在这个社会的下游，作为机械专业的学生，是不甘心吧，当然也是当初自找的，生化环材机友们和所有人一样爱财，也希望自己和家人以后能过得好点，我想我会转互联网/IT吧，如老师所说，大多数人不知道自己喜欢什么，我也是，就专业方面来说，机器人和应用开发 人工智能都挺有好感，但谈不上热衷，大概不是真的喜欢吧，作为生活的一部分，我想我会转互联网，作为爱好追求，我还应该多去了解自己，谢谢老师提点，我以为选择了一个方向就会是生活的全部了，所以害怕决定。<br> 把这个问题公开我觉得挺好的，希望所有有想法的人勇敢一点。</p></blockquote><hr><p>原文地址: <a href="https://face2ai.com/Other-a-mail" target="_blank" rel="noopener">https://face2ai.com/Other-a-mail</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; 一封来自读者的信&lt;br&gt;&lt;strong&gt;Keywords:&lt;/strong&gt; 计算机视觉，就业，人工智能，深度学习&lt;br&gt;
    
    </summary>
    
      <category term="Other" scheme="http://www.face2ai.com/categories/Other/"/>
    
    
      <category term="Other" scheme="http://www.face2ai.com/tags/Other/"/>
    
  </entry>
  
  <entry>
    <title>【杂文】中美人工智能对比（一篇博人关注的软文）</title>
    <link href="http://www.face2ai.com/other-Something-about-Chinese-AI/"/>
    <id>http://www.face2ai.com/other-Something-about-Chinese-AI/</id>
    <published>2018-10-12T02:26:34.000Z</published>
    <updated>2018-10-22T07:14:41.004Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Abstract:</strong> 中国的人工智能大概率在做什么？一篇哗众取宠，博人关注的软文，数据全部来自网络<br><strong>Keywords:</strong> 人工智能<br><a id="more"></a></p><h1 id="中美人工智能从业者小调查"><a href="#中美人工智能从业者小调查" class="headerlink" title="中美人工智能从业者小调查"></a>中美人工智能从业者小调查</h1><p>我是一个人工智能从业者，之间有过相关创业经历，但是由于接触到的投资机构多为小微型，所以，无法从金融，市场角度分析原因，我今天主要说的是从一个比较可观的角度来看看，我们的人工智能开发人员都在干什么？</p><p><strong>写本文的唯一目的就是为了吸引别人关注我的博客或者公众号，这一篇破文章改变不了任何事情，我能做的是保证我的逻辑没问题，数据没问题，至于结论，您爱信就信，不信也无所谓，这对任何人根本没什么任何影响，大概就是这个样子</strong></p><p>本文类似于一道证明题，所有环节紧密相扣，如果中间任何一步您觉得不可信，那么后面都不可信，因为前面的基础都是错误的，后面的一系列论证都是错的了。</p><h2 id="几个前提"><a href="#几个前提" class="headerlink" title="几个前提"></a>几个前提</h2><p>网络是大多数人工智能从业人员获取知识的重要工具，而搜索引擎则起到了至关重要的作用，于是我们提出第一个不证明但是认为是正确的前提(数学中称之为公理，这里我们不这么叫，避免引起歧义)，我们先给这种前提起个名字，叫做 <strong>Tony公理</strong> ，以表示这是个非正式的公理:</p><div class="note primary"><p><strong>Tony公理 1</strong>：人工智能从业者，开发人员通过搜索引擎来获取相关知识，完成自己的职业技能训练</p></div><p>根据第一个<strong>Tony公理</strong>继续我们的思考，国内搜索引擎一家独大，也就是百度，我们这里只谈使用量，不考虑任何其他非相关的事。而全球公认使用量最大的搜索引擎我们假定其是Google，所以我们通过这两个网站给出的两个工具来获得我们本文以下的全部数据和依据：<br><div class="note info"><p><strong>工具 1</strong>：Google Trens<a href="https://trends.google.com/" target="_blank" rel="noopener">https://trends.google.com/</a><br><strong>工具 2</strong>：百度指数 <a href="https://index.baidu.com" target="_blank" rel="noopener">https://index.baidu.com</a></p></div><br>这两个工具都是衡量搜索引擎在某一个事件段内关键词的热度，于是我们接下来用这两个工具来设计我们下面的全部试验。</p><h2 id="中美人工智能对比（视觉方向）"><a href="#中美人工智能对比（视觉方向）" class="headerlink" title="中美人工智能对比（视觉方向）"></a>中美人工智能对比（视觉方向）</h2><p><del>这个标题如果作为大标题会吸引很多眼球，事实上我决定可以这么做，因为本文的目的就是哗众取宠。</del></p><h3 id="对比原理"><a href="#对比原理" class="headerlink" title="对比原理"></a>对比原理</h3><p>了解或是不了解人工智能的读者都不用害怕，我下面用最通俗解释告诉你这些关键词都代表了什么。<br>关键词是你要搜索内容的高度概括，就比如你要买鱼丸粗面，不应该去搜索引擎搜索“蓝球”这个关键词，你搜索什么，代表着你要了解什么。于是我们这里提出第二个 <strong>Tony公理</strong></p><div class="note primary"><p><strong>Tony公理 2</strong>：关键词代表你想要了解的内容</p></div><p>那么作为一个从业者，我来告诉你几个比较有代表性的关键词(主要面向视觉方向，自然语言等不了解，不做解释)，这几个关键词我会对应到我们平时做饭的过程中。这样大家都能理解:</p><ol><li>TensorFlow：是一个开源软件库，用于各种感知和语言理解任务的机器学习。<ul><li>TensorFlow 可以理解为一套工具，包括锅碗瓢盆，勺子，铲子，菜刀，等所有工具</li></ul></li><li>梯度下降(Gradient Descent): 这个是目前被大范围使用的一种优化方法(一种基础算法)</li><li>损失函数(loss function):这个和上面的梯度下降类似，也是研究的入门知识，虽然入门但是很关键。<ul><li>选择梯度下降和损失函数作为关键词的原因是，他们是研究使用优化方法的基石，类似于加法中的1+1，而优化方法对于人工智能就像是做饭中调料精确的搭配比例，需要不断的调整这些油盐酱醋的比例才能获得最好的味道，不至于太咸，也不会太酸。</li></ul></li><li>Mnist: 一个数据集<ul><li>用于入门卷积神经网络的例子，C++中的hello word，做饭中的番茄炒蛋</li></ul></li><li>AlexNet: 一种相对复杂一些的网络结构<ul><li>用于进一步研究卷积神经网络的例子，难度C++的斐波那契数列，做饭中的炖排骨，而AlexNet相当于给出了你代码和菜谱，你的工作就是运行一下。</li></ul></li></ol><h3 id="Google上的对比-——-横向对比"><a href="#Google上的对比-——-横向对比" class="headerlink" title="Google上的对比 —— 横向对比"></a>Google上的对比 —— 横向对比</h3><p>中国和美国大家研究上述方向的比例是什么？<br>我们这里以TensorFlow作为基础指标，其他关键字为其相对的比例，这里的假设是TensorFlow在中美从业者中使用比例近似（比如中国每一百个从业者中有七十个使用tensorflow，美国从业者也应该在七十个左右，如果差的特别离谱，比如美国只有40个，那么本文完全不成立）我们来看中国的关键词热度：</p><p><img src="https://tony4ai-1251394096.cos.ap-hongkong.myqcloud.com/blog_images/other-Something-about-Chinese-AI/markdown-img-paste-20181012120729632.png" alt=""></p><div class="note info"><p>数字代表相对于图表中指定区域和指定时间内最高点的搜索热度。热度最高的字词得 100 分；热度是前者一半的字词得 50 分；没有足够数据的字词得 0 分。</p></div><p>有些看不清，我把最后那几项数据列出来：</p><table><thead><tr><th style="text-align:center">月份</th><th style="text-align:center">梯度下降: (中国)</th><th style="text-align:center">损失函数: (中国)</th><th style="text-align:center">Mnist: (中国)</th><th style="text-align:center">TensorFlow: (中国)</th><th style="text-align:center">AlexNet: (中国)</th></tr></thead><tbody><tr><td style="text-align:center">2017-01</td><td style="text-align:center">3</td><td style="text-align:center">0</td><td style="text-align:center">2</td><td style="text-align:center">45</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">2017-02</td><td style="text-align:center">2</td><td style="text-align:center">0</td><td style="text-align:center">4</td><td style="text-align:center">58</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">2017-03</td><td style="text-align:center">2</td><td style="text-align:center">0</td><td style="text-align:center">2</td><td style="text-align:center">73</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">2017-04</td><td style="text-align:center">2</td><td style="text-align:center">0</td><td style="text-align:center">2</td><td style="text-align:center">73</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">2017-05</td><td style="text-align:center">2</td><td style="text-align:center">0</td><td style="text-align:center">3</td><td style="text-align:center">65</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">2017-06</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">2</td><td style="text-align:center">73</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">2017-07</td><td style="text-align:center">2</td><td style="text-align:center">0</td><td style="text-align:center">2</td><td style="text-align:center">79</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">2017-08</td><td style="text-align:center">2</td><td style="text-align:center">0</td><td style="text-align:center">3</td><td style="text-align:center">78</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">2017-09</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">2</td><td style="text-align:center">77</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">2017-10</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">2</td><td style="text-align:center">74</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">2017-11</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">3</td><td style="text-align:center">90</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">2017-12</td><td style="text-align:center">3</td><td style="text-align:center">0</td><td style="text-align:center">5</td><td style="text-align:center">88</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">2018-01</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">4</td><td style="text-align:center">89</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">2018-02</td><td style="text-align:center">2</td><td style="text-align:center">0</td><td style="text-align:center">2</td><td style="text-align:center">56</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">2018-03</td><td style="text-align:center">3</td><td style="text-align:center">0</td><td style="text-align:center">3</td><td style="text-align:center">83</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">2018-04</td><td style="text-align:center">3</td><td style="text-align:center">0</td><td style="text-align:center">2</td><td style="text-align:center">100</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">2018-05</td><td style="text-align:center">2</td><td style="text-align:center">0</td><td style="text-align:center">3</td><td style="text-align:center">94</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">2018-06</td><td style="text-align:center">3</td><td style="text-align:center">0</td><td style="text-align:center">3</td><td style="text-align:center">86</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">2018-07</td><td style="text-align:center">2</td><td style="text-align:center">0</td><td style="text-align:center">3</td><td style="text-align:center">89</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">2018-08</td><td style="text-align:center">2</td><td style="text-align:center">0</td><td style="text-align:center">3</td><td style="text-align:center">89</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">2018-09</td><td style="text-align:center">2</td><td style="text-align:center">0</td><td style="text-align:center">3</td><td style="text-align:center">86</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">2018-10</td><td style="text-align:center">3</td><td style="text-align:center">0</td><td style="text-align:center">4</td><td style="text-align:center">63</td><td style="text-align:center">1</td></tr></tbody></table><p>接着我们看看美国从业者搜索相关信息的比例：</p><p><img src="https://tony4ai-1251394096.cos.ap-hongkong.myqcloud.com/blog_images/other-Something-about-Chinese-AI/markdown-img-paste-20181012120818509.png" alt=""><br>同样列出最后的数据：</p><table><thead><tr><th style="text-align:center">月份</th><th style="text-align:center">gradient descent: (美国)</th><th style="text-align:center">loss function: (美国)</th><th style="text-align:center">Mnist: (美国)</th><th style="text-align:center">TensorFlow: (美国)</th><th style="text-align:center">AlexNet: (美国)</th></tr></thead><tbody><tr><td style="text-align:center">2017-01</td><td style="text-align:center">5</td><td style="text-align:center">9</td><td style="text-align:center">3</td><td style="text-align:center">50</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">2017-02</td><td style="text-align:center">8</td><td style="text-align:center">13</td><td style="text-align:center">4</td><td style="text-align:center">66</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">2017-03</td><td style="text-align:center">9</td><td style="text-align:center">13</td><td style="text-align:center">5</td><td style="text-align:center">79</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">2017-04</td><td style="text-align:center">8</td><td style="text-align:center">15</td><td style="text-align:center">5</td><td style="text-align:center">84</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">2017-05</td><td style="text-align:center">7</td><td style="text-align:center">10</td><td style="text-align:center">4</td><td style="text-align:center">84</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">2017-06</td><td style="text-align:center">5</td><td style="text-align:center">9</td><td style="text-align:center">4</td><td style="text-align:center">83</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">2017-07</td><td style="text-align:center">6</td><td style="text-align:center">8</td><td style="text-align:center">3</td><td style="text-align:center">75</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">2017-08</td><td style="text-align:center">5</td><td style="text-align:center">8</td><td style="text-align:center">3</td><td style="text-align:center">77</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">2017-09</td><td style="text-align:center">7</td><td style="text-align:center">12</td><td style="text-align:center">4</td><td style="text-align:center">75</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">2017-10</td><td style="text-align:center">10</td><td style="text-align:center">16</td><td style="text-align:center">5</td><td style="text-align:center">85</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">2017-11</td><td style="text-align:center">9</td><td style="text-align:center">14</td><td style="text-align:center">7</td><td style="text-align:center">92</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">2017-12</td><td style="text-align:center">7</td><td style="text-align:center">11</td><td style="text-align:center">5</td><td style="text-align:center">80</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">2018-01</td><td style="text-align:center">6</td><td style="text-align:center">10</td><td style="text-align:center">4</td><td style="text-align:center">78</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">2018-02</td><td style="text-align:center">9</td><td style="text-align:center">15</td><td style="text-align:center">5</td><td style="text-align:center">89</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">2018-03</td><td style="text-align:center">9</td><td style="text-align:center">14</td><td style="text-align:center">5</td><td style="text-align:center">96</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">2018-04</td><td style="text-align:center">9</td><td style="text-align:center">17</td><td style="text-align:center">6</td><td style="text-align:center">100</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">2018-05</td><td style="text-align:center">8</td><td style="text-align:center">12</td><td style="text-align:center">5</td><td style="text-align:center">95</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">2018-06</td><td style="text-align:center">6</td><td style="text-align:center">9</td><td style="text-align:center">4</td><td style="text-align:center">93</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">2018-07</td><td style="text-align:center">6</td><td style="text-align:center">10</td><td style="text-align:center">4</td><td style="text-align:center">89</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">2018-08</td><td style="text-align:center">7</td><td style="text-align:center">9</td><td style="text-align:center">3</td><td style="text-align:center">86</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">2018-09</td><td style="text-align:center">9</td><td style="text-align:center">13</td><td style="text-align:center">5</td><td style="text-align:center">87</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">2018-10</td><td style="text-align:center">11</td><td style="text-align:center">15</td><td style="text-align:center">5</td><td style="text-align:center">83</td><td style="text-align:center">1</td></tr></tbody></table><p>根据上面的对比得出一条结论：</p><p><a href="https://face2ai.com/other-Something-about-Chinese-AI" target="_blank" rel="noopener">美国和中国从业者在使用相同的厨具数量下，美国人比中国人更多人投入研究优化方法，也就是调料的搭配，而在做番茄蛋和炖排骨上，大家的热情差不多。</a></p><h3 id="百度一下，纵向对比中国自己的方向"><a href="#百度一下，纵向对比中国自己的方向" class="headerlink" title="百度一下，纵向对比中国自己的方向"></a>百度一下，纵向对比中国自己的方向</h3><p>然后。。对不起各位。。没有然后了，因为</p><p><img src="/other-Something-about-Chinese-AI/markdown-img-paste-20181012121737134.png" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上文逻辑目前来看没有什么问题，只能做横向对比了，纵向对比我们要“立即购买”，这里我就不去深入研究了。如果有不同的看法，可以用任何正确的逻辑来反驳我，这个我是接受的，因为毕竟我不能统计所有关键词，难免会有错误，但是如果从情怀上来说我不爱什么什么的，那我只能跪在地上给大爷认错，我错了。<br>后面几句牢骚别当真，喜欢的话关注我们的公众号，不过以后不会有这种文章了。</p><hr><p>原文地址: <a href="https://face2ai.com/other-Something-about-Chinese-AI" target="_blank" rel="noopener">https://face2ai.com/other-Something-about-Chinese-AI</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; 中国的人工智能大概率在做什么？一篇哗众取宠，博人关注的软文，数据全部来自网络&lt;br&gt;&lt;strong&gt;Keywords:&lt;/strong&gt; 人工智能&lt;br&gt;
    
    </summary>
    
      <category term="Other" scheme="http://www.face2ai.com/categories/Other/"/>
    
    
      <category term="人工智能" scheme="http://www.face2ai.com/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>【强化学习】2.2 行为评价方法(Action-value Methods)</title>
    <link href="http://www.face2ai.com/RL-RSAB-2-2-Action-value-Methods/"/>
    <id>http://www.face2ai.com/RL-RSAB-2-2-Action-value-Methods/</id>
    <published>2018-10-10T14:03:20.000Z</published>
    <updated>2018-10-11T03:20:05.269Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Abstract:</strong> 本文介绍第一种强化学习方法——行为评价方法(Action-value Methods)，非常简单但是可以通过这个简单的算法来感受下强化学习的难点和问题解决的思路<br><strong>Keywords:</strong> 强化学习, k臂赌博机, 多臂赌博机, 利用, 探索, 行为评价方法，样本均值方法, $\varepsilon$-greedy方法<br><a id="more"></a></p><h1 id="行为评价方法-Action-value-Methods"><a href="#行为评价方法-Action-value-Methods" class="headerlink" title="行为评价方法(Action-value Methods)"></a>行为评价方法(Action-value Methods)</h1><p>本文介绍解决k-臂赌博机的第一种简单的naive的方法，注意区分两个重要的概念，评价方法(value function)产生的值(value)和奖励信号(reward signal)之间的区别。</p><h2 id="评价方法和奖励信号的回顾"><a href="#评价方法和奖励信号的回顾" class="headerlink" title="评价方法和奖励信号的回顾"></a>评价方法和奖励信号的回顾</h2><p>注意我们前面介绍的两个概念，相似但是完全不同，就是评价方法(value function)产生的对行为的评价，以及行为执行后的奖励信号(reward signal)。</p><div class="note info"><p>这里再举个小栗子🌰吧，加入你是个超级富豪，你去街边游戏厅玩一块钱一次的赌博机，当然游戏厅有一排赌博机，假设有 $k$ 个，你随身都带着助理，你的助理是哈佛耶鲁MIT三大名校的统计学博士，你俩去玩赌博机，玩之前，你的助理会告诉你你下一局应该把你的一块钱下注到哪台机器，你肯定要问他他是怎么算出来的，于是，他拿出笔记本电脑，连接到了超级服务器上，用一个超级复杂的公式，评估出了所有赌博机的输赢概率，最后得出，第二台赌博机，赢的概率最大，为90(这个数是博士设计出来的公式的结果)比别的赌博机的对应值都高，所以你心悦诚服的去把你的一块钱压到了二号赌博机。<br>这个例子，你的博士助理就是一个value function或者说他的那套算法是value function也可以，那个90就是某个行为(选择的某台机器的value值)。<br>于是你就去赌博了，堵你的一块钱，经过赌博机的一些列运行，果不其然，你赢了两块钱，你很高兴的买了一个冰棍，你和你的博士朋友一起吃了起来 —— 这里面的两块钱就是reward signal。<br>可见value是和reward signal 完全不同但又息息相关的概念</p></div><p>上面我们应该大概能区分action的value和reward signal了。<br>我们继续回顾我们上文（<a href="https://face2ai.com/RL-RSAB-2-1-A-k-armed-Bandit-Problem" target="_blank" rel="noopener">点击查看详情</a>）讲到的这个公式：<br>$$<br>q_{\ast}(a)\doteq\mathbb{E}[R_t|A_t=a]<br>$$</p><p>公式中 $q_{\ast}(a)$ 是一个函数，表示reward signal的期望，公式中包含了 $R_t$ 为对应的第 $t$ 个过程中的 Reward Signal ，而接着就用<br>$$<br>Q_t(a)\approx q_\ast(a)<br>$$<br>来定义了个value function：换句话说，我们刚弄了个每一步的reward signal的期望，就被人顺水推舟做了value function，因为value function 总是要和reward signal相关的value变大的时候reward signal一定也要对应的变大或者变小也可以，只要他们之间的变化时按照固定规律进行的，我们就能通过value function来最大化reward signal。<br>还有一个区别value 和reward signal的办法是value时选择action之前用的，reward是action之后(甚至是多个actions之后)得到的，来自environment的反馈。</p><p><strong>一定要注意的就是value function和reward signal之间的关联和相互利用，不要糊涂了，我们的最终目的是最大化reward signal</strong></p><h2 id="样本均值-sample-average-method-方法"><a href="#样本均值-sample-average-method-方法" class="headerlink" title="样本均值(sample-average method)方法"></a>样本均值(sample-average method)方法</h2><p>上面已经用reward signal的期望来做value function了，那么我们第一种方法也就这么来了，我们计算 $\text{action}_a$ 在过去所有步骤中出现的时候得到的reward signal平均值，作为$\text{action}_a$ 的value，这就产生了下面这个value function:</p><p>$$<br>Q_t(a)\doteq\frac{\text{a出现的时候reward signal的和}}{\text{a出现的次数}}=\frac{\sum^{t-1}_{i=1}R_i\cdot1_{A_i=a}}{\sum^{t-1}_{i=1}1_{A_i=a}}<br>$$<br>这里面唯一不好理解的就是符号 $1_{A_i=a}$ 这里的1不是一个数值，你可以把它理解为一个布尔变量，他不是值，他是个指示变量，当第 $t$ 步骤中 $A_t$ 采用的是a的话，那么这个值$1_{A_t=a}=1$ 否则 $1_{A_t=a}=0$<br> $R_i$ 就是对应的第 $i$ 步获得的reward signal。所以这个奖励信号就和一个指示函数相乘了，最后求出来当a被使用的时候的reward signal的和了，分母是同样的原理，是一个计数器。<br>如果你学过数字信号或者模拟信号，你会了解有一个叫做使能信号的东西，$1_{A_t=a}$ 与之类似。<br>但是这里有除法就要注意如果我们之前一直没有采用过$\text{action}_a$  那么分母就是0了，所以我们可以硬性规定一下，如果分母为0，那么 $Q_t(a)=0$<br>根据大数定理，当我们的action使用的足够多的时候，样本的期望就是随机变量的期望，对大数定理不太了解的同学可以参考:<a href="https://www.face2ai.com/Math-Probability-6-2-The-Law-of-Large-Numbers/">大数定理</a>也就是说，当我们步骤足够多的话，action也都被大量使用时，$Q_t(a)$ 收敛于 $q_\ast(a)$ 。<br>以上只是一种非常简单的value function的设计，有效与否要等到后面的试验，但是从理论上来说，他是可以满足我们的需求的。<br>那么上面我们就完成value function的设计，接着我们要考虑的就是如何选择 action 了，是 exploitation 和 exploration 呢？</p><h2 id="varepsilon-greedy方法"><a href="#varepsilon-greedy方法" class="headerlink" title="$\varepsilon$-greedy方法"></a>$\varepsilon$-greedy方法</h2><p>第一种，最传统的办法，选择期望最高的，也就是贪心的选择，对应的 action 就属于 exploitation，使用数学表达这个过程就是 在$t$ 步选择$A^{\ast}_{t}$使得 $Q_{t}(A^{\ast}_{t})=\text{max}_aQ_t(a)$ 贪心选择的整体被写作：</p><p>$$<br>A_t\doteq \mathop{\arg\max}_{a} Q_t(a)<br>$$<br>上面这个符号 $\mathop{\arg\max}_{a}$ 会在你的人工智能历程中一直跟你纠缠不休，用中文解释就是在所有可行的 $a$ 中，找到一个能使 $Q_t(a)$ 最大的，并返回这个 $a$ ，也就是$A_t$ 每一步都是使用时 $Q_t(a)$ 最大的 $a$。</p><p><strong>贪心方法最大的问题就是，他每次都使用前面所有行为中看起来最大收益的行为，但是他无法保证这个行为确实是最好的，比如，有一种行为更好，但是前面的几次都发挥失常，没有得到较好的reward signal，这种情况是完全有可能的，而贪心算法解决不了这个问题。</strong></p><p>一种改进就是以一定概率 $\varepsilon$ (相对较小)执行随机选择的行为，选择范围是所有可行的行为，且他们被选择的概率相等,这种随机选择的action就是我们前面提到的exploration，这种方法叫做$\varepsilon$-greedy方法。<br>这种方法的优点是随着学习的不断增长，所有的行为的被执行次数都是趋近于无穷的，那么这时候可以保证 $Q_t(a)$ 收敛于 $q_\ast(a)$。因为我们执行exploitation的概率是 $1-\varepsilon$ 其数值是接近1的，而exploration的概率$\varepsilon$ 是接近0的，当执行了非常多的过程后$Q_t(a)$ 收敛于 $q_\ast(a)$，此时我们有$1-\varepsilon$ 的比例是执行的贪心过程，那么我们的所有步骤中就有不小于 $1-\varepsilon$ 的比例是选择的最大收益的行为，这种结果将会是相当客观的。<br>上面这套理论从字面上看起来近乎完美，但是这个收敛是个渐进的保证，换句话说学习次数在现实中不可能趋近于无限，我们的训练次数也是有限的，我们目前还不能根据一个理论上的极限情况来断定在实际执行过程中也获得很好的表现。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了value function的设计，以及两种方法来选择action，我们从此篇开始，正式进入强化学习的大门。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol><li>Sutton R S, Barto A G. Reinforcement learning: An introduction[J]. 2011.</li></ol><hr><p>原文地址: <a href="https://face2ai.com/RL-RSAB-2-2-Action-value-Methods" target="_blank" rel="noopener">https://face2ai.com/RL-RSAB-2-2-Action-value-Methods</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; 本文介绍第一种强化学习方法——行为评价方法(Action-value Methods)，非常简单但是可以通过这个简单的算法来感受下强化学习的难点和问题解决的思路&lt;br&gt;&lt;strong&gt;Keywords:&lt;/strong&gt; 强化学习, k臂赌博机, 多臂赌博机, 利用, 探索, 行为评价方法，样本均值方法, $\varepsilon$-greedy方法&lt;br&gt;
    
    </summary>
    
      <category term="Reinforcement Learning" scheme="http://www.face2ai.com/categories/Reinforcement-Learning/"/>
    
      <category term="RL-An Introduction" scheme="http://www.face2ai.com/categories/Reinforcement-Learning/RL-An-Introduction/"/>
    
    
      <category term="强化学习" scheme="http://www.face2ai.com/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="多臂赌博机" scheme="http://www.face2ai.com/tags/%E5%A4%9A%E8%87%82%E8%B5%8C%E5%8D%9A%E6%9C%BA/"/>
    
      <category term="k臂赌博机" scheme="http://www.face2ai.com/tags/k%E8%87%82%E8%B5%8C%E5%8D%9A%E6%9C%BA/"/>
    
      <category term="利用" scheme="http://www.face2ai.com/tags/%E5%88%A9%E7%94%A8/"/>
    
      <category term="探索" scheme="http://www.face2ai.com/tags/%E6%8E%A2%E7%B4%A2/"/>
    
      <category term="行为评价方法" scheme="http://www.face2ai.com/tags/%E8%A1%8C%E4%B8%BA%E8%AF%84%E4%BB%B7%E6%96%B9%E6%B3%95/"/>
    
      <category term="样本均值方法" scheme="http://www.face2ai.com/tags/%E6%A0%B7%E6%9C%AC%E5%9D%87%E5%80%BC%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【Hexo】Hexo下next主题valine强化版本的改造</title>
    <link href="http://www.face2ai.com/other-Hexo-next-valine-leancloud/"/>
    <id>http://www.face2ai.com/other-Hexo-next-valine-leancloud/</id>
    <published>2018-10-10T07:03:36.000Z</published>
    <updated>2018-10-15T11:44:16.758Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Abstract:</strong> 本文介绍Valine评论系统的自定义<br><strong>Keywords:</strong> Hexo，Next，Valine评论系统，Valine邮件<br><a id="more"></a></p><h1 id="Hexo下next主题valine强化版本的改造"><a href="#Hexo下next主题valine强化版本的改造" class="headerlink" title="Hexo下next主题valine强化版本的改造"></a>Hexo下next主题valine强化版本的改造</h1><p>使用Hexo下Next主题会遇到评论设置上的麻烦，好用的被墙了，剩下的都不太好用。但是Next集成了一个valine评论很有改造空间。<br>我们这里只提供一个改造思路，具体的执行细节我会给出参考网址。</p><h2 id="使用valine"><a href="#使用valine" class="headerlink" title="使用valine"></a>使用valine</h2><p>按照next或者官方说明，安装是不需要安装什么的，只是要设置下leancloud上的数据段，如果你的文章浏览数据是用leancloud存储的，那么这个过程你应该很了解了，具体的过程可以参考：<br>1. 官网：<a href="https://valine.js.org" target="_blank" rel="noopener">https://valine.js.org</a></p><ol start="2"><li>hexo-theme-next上的issues:<a href="https://github.com/iissnan/hexo-theme-next/pull/1983" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next/pull/1983</a></li></ol><h2 id="第一个Bug"><a href="#第一个Bug" class="headerlink" title="第一个Bug"></a>第一个Bug</h2><p>这是基本的，如果你的网页做过大型优化，比如参考过：<br><a href="https://reuixiy.github.io/" target="_blank" rel="noopener">https://reuixiy.github.io/</a>优化过next主题的同学会在topx中出现Bug,页面会变成只有title和阅读次数的状态，解决办法是修改<code>themes/next/layout/_third-party/comments/valine.swig</code>中的第一行为:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if theme.valine.enable and theme.valine.appid and theme.valine.appkey and page.title !=== '阅读排行'</span><br></pre></td></tr></table></figure></p><p>阅读排行是你topx的page的title根据你的命名适当修改。</p><h2 id="增强Valine"><a href="#增强Valine" class="headerlink" title="增强Valine"></a>增强Valine</h2><p>Valine的评论系统轻量级，所以功能就那么完善，比如邮件通知，你都找不到评论在哪篇文章，所以我找到了一个增强版的Valine：</p><ul><li>赵俊同学的杰作<a href="http://www.zhaojun.im/hexo-valine-modify/" target="_blank" rel="noopener">http://www.zhaojun.im/hexo-valine-modify/</a></li></ul><p>赵同学给出了一个后台的强力解决方案，让我们的邮件通知不那么简陋，也能找到评论再哪篇文章了，为了稳妥起见，一下内容为赵俊同学的博客原文摘录：</p><hr><article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article"><div class="post-block" style="opacity: 1; display: block;"><link itemprop="mainEntityOfPage" href="http://www.zhaojun.im/hexo-valine-modify/"><span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="name" content="赵俊"><meta itemprop="description" content="一个 Java 学习者的博客，分享 Java 干货, VPS 知识, 软件推荐等。"><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="赵俊的博客"></span><header class="post-header" style="opacity: 1; display: block; transform: translateY(0px);"><h2 class="post-title" itemprop="name headline">Hexo 优化 — 支持邮件通知的评论 Valine 增强版</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-01-11 18:15:21" itemprop="dateCreated datePublished" datetime="2018-01-11T18:15:21+08:00">2018-01-11</time> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2018-10-06 14:17:08" itemprop="dateModified" datetime="2018-10-06T14:17:08+08:00">2018-10-06</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Hexo/" itemprop="url" rel="index"><span itemprop="name">Hexo</span></a></span></span></div></header><div class="post-body" itemprop="articleBody" style="opacity: 1; display: block; transform: translateY(0px);"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>此项目是一个对 <a href="https://valine.js.org" target="_blank" rel="noopener">Valine</a> 评论系统的拓展应用，可增强 <code>Valine</code> 的邮件通知功能。基于 Leancloud 的云引擎与云函数。可以提供邮件 <code>通知站长</code> 和 <code>@ 通知</code> 的功能，而且还支持自定义邮件通知模板。</p><p><a href="https://github.com/zhaojun1998/Valine-Admin/blob/master/%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE.md#邮件通知展示" target="_blank" rel="noopener">点击查看演示</a></p><blockquote><p><strong>注：本项目修改于 panjunwen 的项目 : <a href="https://github.com/panjunwen/Valine-Admin" target="_blank" rel="noopener">Valine-Admin</a>，原作者博客: <a href="https://panjunwen.com/valine-admin-document/" target="_blank" rel="noopener">Valine Admin 配置手册</a></strong>, (部分逻辑于功能不同，还请读者不要搞混配置项.)</p></blockquote><a id="more"></a><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p>首先需要确保 Valine 的基础功能是正常的，参考 <a href="https://valine.js.org" target="_blank" rel="noopener">Valine Docs</a>。</p><p>然后进入 <a href="https://leancloud.cn/dashboard/applist.html#/apps" target="_blank" rel="noopener">Leancloud</a> 对应的 Valine 应用中。</p><p>点击 <code>云引擎 -&gt; 设置</code> 填写代码库并保存：<code><a href="https://github.com/zhaojun1998/Valine-Admin" target="_blank" rel="noopener">https://github.com/zhaojun1998/Valine-Admin</a></code></p><p><a data-fancybox="group" href="https://cdn.jun6.net/201804211508_545.png" class="fancybox fancybox.image" rel="noopener" target="_blank"><img width="700" src="https://cdn.jun6.net/201804211508_545.png"></a></p><p>切换到部署标签页，分支使用 master，点击部署即可：<br><a data-fancybox="group" href="https://cdn.jun6.net/201801112055_212.png" class="fancybox fancybox.image" rel="noopener" target="_blank"><img width="700" src="https://cdn.jun6.net/201801112055_212.png"></a><br><a data-fancybox="group" href="https://cdn.jun6.net/201804211336_271.png" class="fancybox fancybox.image" rel="noopener" target="_blank"><img width="700" src="https://cdn.jun6.net/201804211336_271.png"></a></p><h2 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h2><p>此外，你需要设置云引擎的环境变量以提供必要的信息，点击云引擎的设置页，设置如下信息：</p><p><a data-fancybox="group" href="https://cdn.jun6.net/201806062257_798.png" class="fancybox fancybox.image" rel="noopener" target="_blank"><img width="700" src="https://cdn.jun6.net/201806062257_798.png"></a></p><p><strong>必选参数</strong></p><ul><li><code>SITE_NAME</code> : 网站名称。</li><li><code>SITE_URL</code> : 网站地址, <strong>最后不要加 <code>/</code> 。</strong></li><li><code>SMTP_USER</code> : SMTP 服务用户名，一般为邮箱地址。</li><li><code>SMTP_PASS</code> : SMTP 密码，一般为授权码，而不是邮箱的登陆密码，请自行查询对应邮件服务商的获取方式</li><li><code>SMTP_SERVICE</code> : 邮件服务提供商，支持 <code>QQ</code>、<code>163</code>、<code>126</code>、<code>Gmail</code>、<code>“Yahoo”</code>、<code>……</code> ，全部支持请参考 : <a href="https://nodemailer.com/smtp/well-known/#supported-services" target="_blank" rel="noopener">Nodemailer Supported services</a>。</li><li><code>SENDER_NAME</code> : 寄件人名称。</li></ul><h2 id="高级配置"><a href="#高级配置" class="headerlink" title="高级配置"></a>高级配置</h2><p><a href="https://github.com/zhaojun1998/Valine-Admin/blob/master/%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE.md#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%82%AE%E4%BB%B6%E6%A8%A1%E6%9D%BF" target="_blank" rel="noopener">自定义邮件模板</a></p><p><a href="https://github.com/zhaojun1998/Valine-Admin/blob/master/%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE.md#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%94%B6%E4%BB%B6%E9%82%AE%E7%AE%B1" target="_blank" rel="noopener">自定义收件邮箱</a></p><p><a href="https://github.com/zhaojun1998/Valine-Admin/blob/master/%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE.md#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8" target="_blank" rel="noopener">自定义邮件服务器</a></p><p><a href="https://github.com/zhaojun1998/Valine-Admin/blob/master/%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE.md#web-%E8%AF%84%E8%AE%BA%E7%AE%A1%E7%90%86" target="_blank" rel="noopener">Web 评论管理</a></p><p><a href="https://github.com/zhaojun1998/Valine-Admin/blob/master/%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE.md#leancloud-%E4%BC%91%E7%9C%A0%E7%AD%96%E7%95%A5" target="_blank" rel="noopener">Leancloud 休眠策略(必看)</a></p><h2 id="更新历史"><a href="#更新历史" class="headerlink" title="更新历史"></a>更新历史</h2><ul><li>7.7 兼容 <code>valine v1.2.0-beta</code> 版本对 at 的更改 <a href="https://valine.js.org/changelog.html#v1-2-0-beta-2018-06-30" target="_blank" rel="noopener">点击查看</a>。</li><li>7.1 修复 <code>Web</code> 后台登录安全 <code>bug</code></li><li>6.14 添加自定义邮件服务器功能. <a href="/高级配置.md#自定义邮件服务器">点击查看</a></li></ul><h2 id="升级-FAQ"><a href="#升级-FAQ" class="headerlink" title="升级 FAQ"></a>升级 FAQ</h2><p><strong>部署最新代码 :</strong></p><p><a data-fancybox="group" href="https://cdn.jun6.net/201806070911_388.png" class="fancybox fancybox.image" rel="noopener" target="_blank"><img src="https://cdn.jun6.net/201806070911_388.png" width="600"></a></p><p><strong>重启容器:</strong></p><p><a data-fancybox="group" href="https://cdn.jun6.net/201807081507_968.png" class="fancybox fancybox.image" rel="noopener" target="_blank"><img width="500" src="https://cdn.jun6.net/201807081507_968.png"></a></p><blockquote><p><strong>注: 更新新版本与更改环境变量均需要重启容器后生效。</strong></p></blockquote><h2 id="LeanCloud-休眠策略"><a href="#LeanCloud-休眠策略" class="headerlink" title="LeanCloud 休眠策略"></a>LeanCloud 休眠策略</h2><p>免费版的 LeanCloud 容器，是有强制性休眠策略的，不能 24 小时运行：</p><ul><li>每天必须休眠 6 个小时</li><li>30 分钟内没有外部请求，则休眠。</li><li>休眠后如果有新的外部请求实例则马上启动（但激活时此次发送邮件会失败）。</li></ul><p>分析了一下上方的策略，如果不想付费的话，最佳使用方案就设置定时器，每天 7 - 23 点每 20 分钟访问一次，这样可以保持每天的绝大多数时间邮件服务是正常的。</p><p>附 <code>Linux crontab</code> 定时器代码：</p><div class="highlight-wrap"><button class="copy-btn">复制</button><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><em>/20 7-23 </em> <em> </em> curl https://你配置的域名前缀.leanapp.cn</span><br></pre></td></tr></tbody></table></figure></div><p>注 : 此 <code>crontab</code> 不是<code>LeanCloud</code> 后台的定时任务，如果你没有 <code>Linux</code> 机器来配置此定时器，那么可以在此 <a href="https://github.com/zhaojun1998/Valine-Admin/issues/1" target="_blank" rel="noopener">issues</a> 中回复我，我帮你加上。</p><blockquote><p>如对本项目有意见或建议，欢迎去 Github 提 <a href="https://github.com/zhaojun1998/Valine-Admin/issues" target="_blank" rel="noopener">issues</a>。</p></blockquote></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Hexo优化/" rel="tag"># Hexo优化</a> <a href="/tags/Valine/" rel="tag"># Valine</a> <a href="/tags/评论系统/" rel="tag"># 评论系统</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/nice_blog/" rel="next" title="怎样才算一个好的技术博客？"><i class="fa fa-chevron-left"></i> 怎样才算一个好的技术博客？</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/hexo-lazyload/" rel="prev" title="Hexo 优化 --- lazyload 图片懒加载">Hexo 优化 — lazyload 图片懒加载 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><hr><p>希望赵同学的博客不会关闭github也不会删库，这样的结果就是我们的邮件通知会美观很多，而且还附加了评论所在地址，非常方便。<br>如果使用上述后台设置那么在主题下的配置文件，valine选项中的邮件通知要关掉，不然会收到两份通知：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">valine:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  appid: xxxxxx</span><br><span class="line">  appkey: xxxxxxx</span><br><span class="line">  notify: <span class="literal">false</span> <span class="comment"># mail notifier , https://github.com/xCss/Valine/wiki</span></span><br><span class="line">  verify: <span class="literal">true</span> <span class="comment"># Verification code</span></span><br><span class="line">  placeholder: 无需注册，填写正确的邮箱，评论被回复就有邮件通知了~ <span class="comment"># comment box placeholder</span></span><br><span class="line">  avatar: retro <span class="comment"># gravatar style</span></span><br><span class="line">  guest_info: nick,mail,link <span class="comment"># custom comment header</span></span><br><span class="line">  pageSize: 10 <span class="comment"># pagination size</span></span><br><span class="line">  visitor: <span class="literal">false</span></span><br></pre></td></tr></table></figure></p><hr><p>原文地址: <a href="https://face2ai.com/other-Hexo-next-valine-leancloud" target="_blank" rel="noopener">https://face2ai.com/other-Hexo-next-valine-leancloud</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; 本文介绍Valine评论系统的自定义&lt;br&gt;&lt;strong&gt;Keywords:&lt;/strong&gt; Hexo，Next，Valine评论系统，Valine邮件&lt;br&gt;
    
    </summary>
    
      <category term="Other" scheme="http://www.face2ai.com/categories/Other/"/>
    
    
      <category term="Hexo" scheme="http://www.face2ai.com/tags/Hexo/"/>
    
      <category term="Next" scheme="http://www.face2ai.com/tags/Next/"/>
    
      <category term="Valine评论系统" scheme="http://www.face2ai.com/tags/Valine%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Valine邮件" scheme="http://www.face2ai.com/tags/Valine%E9%82%AE%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>【强化学习】2.1 k臂赌博机(k-armed bandits)问题</title>
    <link href="http://www.face2ai.com/RL-RSAB-2-1-A-k-armed-Bandit-Problem/"/>
    <id>http://www.face2ai.com/RL-RSAB-2-1-A-k-armed-Bandit-Problem/</id>
    <published>2018-10-08T14:40:24.000Z</published>
    <updated>2018-10-12T04:28:56.598Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Abstract:</strong> 在强化学习中，平衡Exploitation和Exploration将会是一个从始至终的问题，我们本章用简单的k臂赌博机问题来从具体的每一步来分析和研究这个问题，本节先介绍下问题的描述和大概的解决思路，为本章后面的问题解决做好铺垫<br><strong>Keywords:</strong> 强化学习，k臂赌博机，多臂赌博机，利用，探索，Exploitation，Exploration<br><a id="more"></a></p><h1 id="k臂赌博机（k-armed-bandits）问题"><a href="#k臂赌博机（k-armed-bandits）问题" class="headerlink" title="k臂赌博机（k-armed bandits）问题"></a>k臂赌博机（k-armed bandits）问题</h1><p>赌博机，说到赌博，大家都觉得这是一个非常不好的活动，但是说回来，赌博是催生数理统计和概率的主要动力，具体可以看未完成的系列：<a href="https://www.face2ai.com/categories/Mathematic/Statistics/">数理统计学简史</a><br>作为不赌博的好孩子，大部分人对k臂赌博机可能不是很了解，首先我们来介绍一下这种赌博机：<br><img src="https://tony4ai-1251394096.cos.ap-hongkong.myqcloud.com/blog_images/RL-RSAB-2-1-A-k-armed-Bandit-Problem/armed_bandit.jpg" alt=""><br>这就是为什么是<strong>k臂</strong>赌博机，那个臂就是旁边的控制器，通过拉动控制器就能出发机器开关，当出现指定的图案就会有相应的奖励，这是<strong>1臂</strong>赌博机，如果有多个这种机器放在一排，那么这就是<strong>k臂</strong>赌博机。</p><h2 id="k臂赌博机问题描述"><a href="#k臂赌博机问题描述" class="headerlink" title="k臂赌博机问题描述"></a>k臂赌博机问题描述</h2><p>下面我们来从学术的角度描述一下这个问题，描述如下：<br>我们面对的选择包含 $k$ 个选项，或者 $k$ 种可选的行为，每一个选择或者行为都对应了一个奖励信号(rewarding signal，忘记了回到前面看看) 每种选择对应的奖励信号是随机的，但是都来自固定的分布，当然来自不同选择的奖励信号服从的分布都不同，但是不会随时间改变，比如，$k$ 种可选的行为中 $f_1$ 表示第一种行为的奖励信号的随机分布，其可以不同于 $f_2$ 也就是第二种行为的奖励信号的随机分布，但是为了简化问题，我们目前研究的问题中 $f_1,f_2,\dots,f_k$ 都不随时间变化。<br>我们的目的是通过每一步观察，选择，执行不同行为来最大化我们的奖励信号，当然这个过程需要长时间，或者是多步以后来观察结果，一次或者两次的观察是没有研究意义的。</p><h3 id="k臂赌博机"><a href="#k臂赌博机" class="headerlink" title="k臂赌博机"></a>k臂赌博机</h3><p>经过上面的描述，我们就可以把描述和赌博机联系在一起了，首先我们对赌博机进行如下假设：</p><ol><li>赌博机出现的结果都是满足某种随机分布的，当然这个可能是赌场老板设定的，也可以是自然产生的</li><li>赌场里面有很多赌博机可以供我们选择，如果赌场就一个赌博机，我们就要换一家研究k-armed bandits problem了</li><li>赌博机的内的设置不会随时间改变，也就是1中的分布不随时间改变，没有幕后黑手操控比赛</li></ol><p>有上面三点假设，我们就可以解释为什么我们本章研究的问题的是k臂赌博机了，我们面对 $k$ 个赌博机，我们的目的是最大化我们的收益，所以我们的做法是选择一个赌博机，然后下注（假定从始至终都不变）启动所有机器，获得结果，观察其他机器的行为，决定下一局是否换别的机器下注，对应上面的问题：</p><ul><li><strong>奖励信号</strong> 对应 <strong>单次赌博收益</strong></li><li><strong>可选行为</strong> 对应 <strong>本次使用哪台机器</strong></li><li><strong>每个行为对应的奖励信号的随机分布</strong> 对应 <strong>每台赌博机出现不同结果的随机分布</strong></li></ul><p>所以这就是我们上面描述的问题的生活中的例子，或者说我们可以通过生活中这个例子来得到问题。</p><p>上面的例子是赌博机的例子，下面还有一个类似的类比，就是医生看病的例子，医生每天要面对一些列的病人，每个病人用什么样的治疗方案就是一个选择的过程，而每种选择都对应着不同效果，而治疗效果就是奖励信号，当医生面对络绎不绝的病人时，医生的目标就是把奖励信号最大化，也就是最大程度的让更多人康复，这个类比也符合上面我们的问题描述</p><ul><li><strong>奖励信号</strong> 对应 <strong>病人康复程度</strong></li><li><strong>可选行为</strong> 对应 <strong>可选的治疗方案</strong></li><li><strong>每个行为对应的奖励信号的随机分布</strong> 对应 <strong>每种治疗方案对当前患者的效果的随机分布</strong></li></ul><h3 id="数学描述"><a href="#数学描述" class="headerlink" title="数学描述"></a>数学描述</h3><p>把上面的语言描述转换成数学描述就是如下了：<br>当前为第 $t$ 次选择(对应赌博中的第 $t$ 局，医生的第 $t$ 个患者), 有 $k$ 中选择，我们在此次选择的行为是： $A_t$ 对应获得的奖励信号是 $R_t$ ，那么对于这一轮选择，假设我们选择了 $a$ 我们获得奖励信号的期望 $q_*$ 就是：<br>$$<br>q_{\ast}(a)\doteq\mathbb{E}[R_t|A_t=a]<br>$$</p><p>如果你对 $A_t$ 和 $a$ 搞不清楚，我可以大概说一下，$A_t$ 是一个总称，本轮的所有选择的总称， 而  $a$  是特定的一个行为，所以期望的公式就可以解释的清楚了，因为不同行为对应不同的分布，而我们希望使用期望来衡量这个行为的奖励信号。<br>如果我们明确知道每一步(局)每个行为(机器)将会出什么结果，那么我们就不需要选择了，直接选最大的那个就好了，所以我们这里假定我们不知道，也许你大概知道期望，但是对结果还是无法确定的（你可以一直观察某个赌博机的结果，利用大数定理通过采样结果来估计原始分布的结果）<br>这里我们对 $t$ 步的特定行为 $a$ 的评价(前面说的value function中value，和rewarding signal直接相关)的期望进行定义：<br>$$<br>Q_t(a)\approx q_*(a)<br>$$</p><p>这样就可以利用我们上面对问题的分析，以及使用前面提到的value function来解决这个问题了</p><h2 id="强化学习解决k臂赌博机问题"><a href="#强化学习解决k臂赌博机问题" class="headerlink" title="强化学习解决k臂赌博机问题"></a>强化学习解决k臂赌博机问题</h2><p>上面我们应该已经能从整体上掌握<strong>k臂赌博机</strong>的问题过程了，那么我们接下来就要用我们前面提到的一些概念来解决这个问题了。<br>如果从我们自身出发，我们希望每一步都能最大化我们的收益（或者叫做奖励信号），我们自身会对所有赌博机都有一个评估，无论是感性的还是理性的，我们都会认为某个或者某几个赌博机获得高回报的可能性大一些，那么我们就有很多种玩法了：</p><ol><li>贪婪的我 —— 每次都玩那个我认为回报高的赌博机</li><li>任性的我 —— 每次随便玩，就是不选我认为回报高的</li><li>会强化学习的我 —— 每贪婪若干次后任性一次（玩自认为回报高的机器几次后，随机玩一次别的机器，看看是否会改变自己前面的观点）</li></ol><p>前面我们反复说过两个单词（第一次考托福的时候我还用这两个单词写过作文😜）”exploitation” or “exploration” ，上面1中的贪婪也被称为 “greedy actions” 当你选择这种action的时候，你的action对应的就是”exploitation”；相反，如果我们就是不选我们认为回报高的，也就是2的这种行为，我们称为 “exploration”，如果我们还是想赢点钱，这种行为也不是完全傻瓜的，因为我们可以通过这种行为来纠正我们对每台机器回报高低的期望（有可能你对机器回报高低的判断是错误的，实际上也是这样的），换句话说，每台机器回报高低我们根本就是乱猜，所以1中的贪婪也有可能执迷不悟，而通过偶尔的”2”一下，没准会得到更多的收获，也就是3中给出的做法，会有更多收获。<br>Exploitation的做法肯定是正确的，但是从长期来看Exploration可能会产生更高的收益(短期来看exploration的收益大概率不如exploitation)，因为exploration很有可能找到比当前执行的action收益更高的其他action。但是具体怎么安排或者说怎么平衡Exploitation和exploration就是我们今后要一直研究的问题了。我们经常会用 “conflict” 来形容Exploitation和Exploration之间的选择。<br>是Exploitation还是Exploration这个问题理论上是没有通用解的，每一个环境，每一个问题，每一步都是不一样的，也无法确定，对于k臂赌博机问题，目前有一些专用的数学公式可以比较好的平衡Exploitation和Exploration之间的关系，但是这些公式或多或少都对问题的某些方面进行了限制和假设，这就使得这些方法在相似问题的不同环境下可能会失效。在后面章节我们研究的全面的强化学习(Fall Reinforcement Learning Problem, <strong>k臂赌博机</strong> 问题是简化后的问题)的时候，对应的环境会变得不同，一些假设条件也会不成了，这时候这些方法也会失效。这时候(某些假设不成立的时候)算法对应的收敛性和收敛边界都会失效。<br>我们目前的研究不关心是否以一种高效，漂亮的（sophisticated）方法来平衡Exploitation和Exploration，而是只要能平衡就行，不管漂不漂亮，高不高效，本章我们就列举几个简单的方法来平衡他们来获得比只 exploitation更好的结果。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在强化学习中，平衡Exploitation和Exploration将会是一个从始至终的问题，我们本章用简单的k臂赌博机问题来从具体的每一步来分析和研究这个问题，从而获得更直观，更详细的理解。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol><li>Sutton R S, Barto A G. Reinforcement learning: An introduction[J]. 2011.</li></ol><hr><p>原文地址:<a href="https://face2ai.com/RL-RSAB-2-1-A-k-armed-Bandit-Problem" target="_blank" rel="noopener"> https://face2ai.com/RL-RSAB-2-1-A-k-armed-Bandit-Problem</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; 在强化学习中，平衡Exploitation和Exploration将会是一个从始至终的问题，我们本章用简单的k臂赌博机问题来从具体的每一步来分析和研究这个问题，本节先介绍下问题的描述和大概的解决思路，为本章后面的问题解决做好铺垫&lt;br&gt;&lt;strong&gt;Keywords:&lt;/strong&gt; 强化学习，k臂赌博机，多臂赌博机，利用，探索，Exploitation，Exploration&lt;br&gt;
    
    </summary>
    
      <category term="Reinforcement Learning" scheme="http://www.face2ai.com/categories/Reinforcement-Learning/"/>
    
      <category term="RL-An Introduction" scheme="http://www.face2ai.com/categories/Reinforcement-Learning/RL-An-Introduction/"/>
    
    
      <category term="强化学习" scheme="http://www.face2ai.com/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="多臂赌博机" scheme="http://www.face2ai.com/tags/%E5%A4%9A%E8%87%82%E8%B5%8C%E5%8D%9A%E6%9C%BA/"/>
    
      <category term="k臂赌博机" scheme="http://www.face2ai.com/tags/k%E8%87%82%E8%B5%8C%E5%8D%9A%E6%9C%BA/"/>
    
      <category term="利用" scheme="http://www.face2ai.com/tags/%E5%88%A9%E7%94%A8/"/>
    
      <category term="探索" scheme="http://www.face2ai.com/tags/%E6%8E%A2%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>【强化学习】2.0 多臂赌博机</title>
    <link href="http://www.face2ai.com/RL-RSAB-2-0-Multi-Armed-Bandits/"/>
    <id>http://www.face2ai.com/RL-RSAB-2-0-Multi-Armed-Bandits/</id>
    <published>2018-10-07T09:03:13.000Z</published>
    <updated>2018-10-07T10:10:00.655Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Abstract:</strong> 本文是第二章“多臂赌博机”的绪论，介绍本章主要内容<br><strong>Keywords:</strong> 强化学习，多臂赌博机<br><a id="more"></a></p><h1 id="多臂赌博机"><a href="#多臂赌博机" class="headerlink" title="多臂赌博机"></a>多臂赌博机</h1><p>强化学习与其他学习算法最大的不同在于训练信息，我们熟知的监督学习，无论从简单的线性回归，到复杂的深度学习，所有这些监督学习用到的训练信息都是Instructing（指导，讲授）的，也就是说训练信息中包含明确的行为指导，比如对于一张输入图片判断是否有人脸，标记好的训练数据会明确的对结果进行校正——是否有人脸，如果有人脸在哪，训练模型偏差会被准确计算，同时通过优化算法逐步减少这个偏差，直到我们设定的阈值后完成训练。<br>而强化学习的训练信息则不同，强化学习的每一步没有指导信息，而是只有一个“评价”（evaluate），评价这个行为(action)的得分，得分也就是好坏，但是没有正确错误的说法，也没有最好或者最坏的说法。<br>这种评价机制导致了强化学习需要在学习的过程中加入探索(exploration)，来用trial-and-error的搜索方式得到好的模型。</p><h2 id="“指导”型反馈和“评价”型反馈"><a href="#“指导”型反馈和“评价”型反馈" class="headerlink" title="“指导”型反馈和“评价”型反馈"></a>“指导”型反馈和“评价”型反馈</h2><p>两种不同的训练信息产生两种不同的反馈模型：</p><ul><li>Purely Evaluative Feedback<ul><li>简单的评价型反馈，只是反馈一个值，这个值评价行为的好坏，注意Purely这个修饰，也就是朴素的，简单的评价反馈是只返回一个值，而复杂的评价反馈可能结合别的信息。</li></ul></li><li>Purely Instructive Feedback<ul><li>与评价反馈不同，指导型反馈，直接返回正确的做法，而且是当action完成的一瞬间就能反馈这个信息，当然这个也是purely的版本，不包含复杂的附加信息。</li></ul></li></ul><p><strong>指导型反馈是监督学习的基础</strong>,以上两种反馈的区别为：</p><ol><li>评价型反馈完全取决于行为（action）</li><li>指导型反馈独立于行为（action）</li></ol><p>当然这两个反馈也不是水火不容，只要你愿意，他们还是可以结合在一起使用的；1中评价性反馈与行为相关可能很好理解，2中的指导型反馈独立于行为可能不太好理解，我们可以这么理解，如果我们输入的信息是N个类别的数据，那么反馈信息就是当前这条数据的正确分类，而这个分类就是独立于算法做出行为的独立反馈。</p><h2 id="本章重点"><a href="#本章重点" class="headerlink" title="本章重点"></a>本章重点</h2><p>本章我们主要研究评价型在简化的强化学习上的应用，简化到什么程度？只有一个situation，已经有很多人研究过使用评价型反馈解决这些问题，这种简化可以避免让我们一开始就陷入复杂关系的问题中，而无法看到强化学习的细节，而且这种简化的模型可以让我们清楚的看到evaluative feedback和instruct feedback的不同，以及帮助我们发现如何将他们联合起来的方法。<br>这种特殊的，无关联的评价性反馈问题，可以有很多具体例子，在本章中，我们用简化的 <strong>多臂赌博机(k-armed bandit)</strong> 作为研究对象。通过这个问题介绍一些简单的方法。这些方法在后续章节中将会被扩展为能解决 <strong>完整强化学习问题</strong> 的方法。<br>本章最后我们会简单的了解一下<strong>完整的强化学习问题</strong> 以及多臂赌博机之间相互影响的时候的问题 —— 也就是多situation的情况。<br><img src="https://tony4ai-1251394096.cos.ap-hongkong.myqcloud.com/blog_images/RL-RSAB-2-0-Multi-Armed-Bandits/octopus.jpg" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可能你对单situation和多situation还不太能区分，或者你可能连多臂赌博机是什么都不知道，但是没关系，我们后面会用一章的时间研究这个赌博机。<br>感谢您的阅读，请多提宝贵意见</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol><li>Sutton R S, Barto A G. Reinforcement learning: An introduction[J]. 2011.</li></ol><hr><p>原文地址:<a href="https://face2ai.com/RL-RSAB-2-0-Multi-Armed-Bandits" target="_blank" rel="noopener"> https://face2ai.com/RL-RSAB-2-0-Multi-Armed-Bandits</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; 本文是第二章“多臂赌博机”的绪论，介绍本章主要内容&lt;br&gt;&lt;strong&gt;Keywords:&lt;/strong&gt; 强化学习，多臂赌博机&lt;br&gt;
    
    </summary>
    
      <category term="Reinforcement Learning" scheme="http://www.face2ai.com/categories/Reinforcement-Learning/"/>
    
      <category term="RL-An Introduction" scheme="http://www.face2ai.com/categories/Reinforcement-Learning/RL-An-Introduction/"/>
    
    
      <category term="强化学习" scheme="http://www.face2ai.com/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="多臂赌博机" scheme="http://www.face2ai.com/tags/%E5%A4%9A%E8%87%82%E8%B5%8C%E5%8D%9A%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>【Julia】整型和浮点型数字</title>
    <link href="http://www.face2ai.com/Julia-Lang-4-Integers-and-Floating-Point-Numbers/"/>
    <id>http://www.face2ai.com/Julia-Lang-4-Integers-and-Floating-Point-Numbers/</id>
    <published>2018-10-03T10:04:56.000Z</published>
    <updated>2018-10-06T13:38:52.067Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Abstract:</strong> 本文介绍Julia语言的整型和浮点型数字的<br><strong>Keywords:</strong><br><a id="more"></a></p><h1 id="整型和浮点型数字"><a href="#整型和浮点型数字" class="headerlink" title="整型和浮点型数字"></a>整型和浮点型数字</h1><p>整数或者浮点数在编程中被大量使用，由于大部分程序面对的问题都是处理数字计算相关的问题，所以数字的表示变成了代码中最重要的一部分。不论是加减乘除，还是积分微分，在计算机中，都要使用整型和浮点型来完成，至于整型和浮点型计算过程中需要注意的事项，这是在数值分析，数值计算课程中需要考虑的，<a href="https://www.face2ai.com/categories/Mathematic/Numerical-Analysis/">数值分析课程传送门</a>，整形变量例如 <code>1</code> 浮点型变量例如<code>1.0</code>。<br>这两个例子中的数字是我们在日常和编码的时候使用的，我们称之为<strong>字面值</strong>（immediate values，对于翻译成立即数的那些教材，我们不予评价，嘻嘻）。而他们在内存中的二进制形式，被称为<strong>原始值</strong>（numeric primitives）。<br>Julia提供了宽泛的原始值类型，和定义在他们之上的一个完整数字计算操作、按位计算操作以及数值函数操作。这些原始值类型都是现在计算机原生支持的，所以Julia可以高效利用计算机的计算资源。Julia也提供了主观定义的计算操作（arbitrary precision arithmetic），这些操作不被硬件支持，在计算过程中速度将会变得比较慢。</p><ul><li>整型变量</li></ul><table><tbody><tr><th>类型</th><th>是否有符号?</th><th>所占位数</th><th>最小值</th><th>最大值</th></tr><tr><td><code>Int8</code></td><td>✓</td><td>8</td><td>-2^7</td><td>2^7 - 1</td></tr><tr><td><code>UInt8</code></td><td></td><td>8</td><td>0</td><td>2^8 - 1</td></tr><tr><td><code>Int16</code></td><td>✓</td><td>16</td><td>-2^15</td><td>2^15 - 1</td></tr><tr><td><code>UInt16</code></td><td></td><td>16</td><td>0</td><td>2^16 - 1</td></tr><tr><td><code>Int32</code></td><td>✓</td><td>32</td><td>-2^31</td><td>2^31 - 1</td></tr><tr><td><code>UInt32</code></td><td></td><td>32</td><td>0</td><td>2^32 - 1</td></tr><tr><td><code>Int64</code></td><td>✓</td><td>64</td><td>-2^63</td><td>2^63 - 1</td></tr><tr><td><code>UInt64</code></td><td></td><td>64</td><td>0</td><td>2^64 - 1</td></tr><tr><td><code>Int128</code></td><td>✓</td><td>128</td><td>-2^127</td><td>2^127 - 1</td></tr><tr><td><code>UInt128</code></td><td></td><td>128</td><td>0</td><td>2^128 - 1</td></tr><tr><td><code>Bool</code></td><td>N/A</td><td>8</td><td><code>false</code> (0)</td><td><code>true</code> (1)</td></tr></tbody></table><ul><li>浮点型变量</li></ul><table><tbody><tr><th>类型</th><th>精度</th><th>所占位数</th></tr><tr><td><code>Float16</code></td><td><a href="https://en.wikipedia.org/wiki/Half-precision_floating-poInt_format" target="_blank" rel="noopener">half</a></td><td>16</td></tr><tr><td><code>Float32</code></td><td><a href="https://en.wikipedia.org/wiki/Single_precision_floating-poInt_format" target="_blank" rel="noopener">single</a></td><td>32</td></tr><tr><td><code>Float64</code></td><td><a href="https://en.wikipedia.org/wiki/Double_precision_floating-poInt_format" target="_blank" rel="noopener">double</a></td><td>64</td></tr></tbody></table><p>以上浮点型的三种类型的精度可以点击进入wikipedia查看详情。</p><h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><p>在Julia编程中字面值以标准形式表示，比如我们想输入数值1，只需要输入<code>1</code>就可以了，而不需要转换成存储在计算机内存或硬盘中的二进制。<br>比如在交互模式下：</p><pre><code>$ julia               _   _       _ _(_)_     |  Documentation: https://docs.julialang.org  (_)     | (_) (_)    |   _ _   _| |_  __ _   |  Type "?" for help, "]?" for Pkg help.  | | | | | | |/ _` |  |  | | |_| | | | (_| |  |  Version 1.0.0 (2018-08-08) _/ |\__'_|_|_|\__'_|  |  Official https://julialang.org/ release|__/                   |julia> 11julia> 123123julia></code></pre><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p><code>typeof</code>的用法和c语言中的 <code>sizeof</code>类似，但是<code>sizeof</code>在c/c++中是操作符，而<code>typeof</code>在Julia这里可能是个函数，这需要我们后面深入的研究确定，我们先画个问号在这。在交互模式下我们来看看我们的整形变量1在Julia中的类型：</p><pre><code>julia> typeof(1)Int64julia> typeof(123)Int64julia></code></pre>输出结果是<code>Int64</code>，不是<code>Int32</code>的原因是我们的操作系统是64位操作系统，所以基础类型就是64位的了。### Sys.WORD_SIZE<code>Sys.WORD_SIZE</code>这个内置变量用于指示当前系统是32位还是64位：<pre><code>julia> Sys.WORD_SIZE64julia></code></pre><h3 id="Int-和-UInt"><a href="#Int-和-UInt" class="headerlink" title="Int 和 UInt"></a>Int 和 UInt</h3><p>这两种类型的不同在于是否有符号，数值范围也有区别，具体的可以从上面的表中得出，如果想看当前系统内的<code>Int</code>和<code>UInt</code>对应位数，可以直接在交互模式下输入：</p><pre><code class="language-julia-repl hljs"># 32-bit system:<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-built_in">Int</span></span>Int32<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-built_in">UInt</span></span>UInt32# 64-bit system:<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-built_in">Int</span></span>Int64<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-built_in">UInt</span></span>UInt64</code></pre>32位系统和64位系统对应如上.**注意：Julia大小写敏感，所以uInt和UInt是不同**<pre><code>julia> uIntERROR: UndefVarError: uInt not definedjulia> UIntERROR: UndefVarError: UInt not definedjulia> UIntUInt64</code></pre><h3 id="输入类型"><a href="#输入类型" class="headerlink" title="输入类型"></a>输入类型</h3><p>如果我们的系统是32位系统，所以对应的整数默认类型是<code>Int32</code>那么如果整数值超过了32-bit有符号型整数的范围，在C语言中就会发生溢出，但是在Julia中，系统会自动将超过32-bit的数字转换成64-bit形式（C语言中在代码中定义类型，所以输入可能会溢出，但是Julia中不事先定义变量类型，所以可以自主转换）：</p><pre><code class="language-julia-repl hljs"># 32-bit or 64-bit system:<span class="hljs-meta">julia&gt;</span><span class="julia"> typeof(<span class="hljs-number">3000000000</span>)</span>Int64</code></pre><p>所以Julia中不会出现溢出这种风险。</p><h3 id="16进制-base-16"><a href="#16进制-base-16" class="headerlink" title="16进制(base 16)"></a>16进制(base 16)</h3><p>常用的16进制当然也是支持的，16进制以 <code>0x</code> 开头，使用<code>0-9a-f</code>作为每一位字面值的数字，这里的 <code>a-f</code>与<code>A-F</code>是等价的：</p><pre><code class="language-julia-repl hljs"><span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">0x1</span></span>0x01<span class="hljs-meta">julia&gt;</span><span class="julia"> typeof(ans)</span>UInt8<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">0x123</span></span>0x0123<span class="hljs-meta">julia&gt;</span><span class="julia"> typeof(ans)</span>UInt16<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">0x1234567</span></span>0x01234567<span class="hljs-meta">julia&gt;</span><span class="julia"> typeof(ans)</span>UInt32<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">0x123456789abcdef</span></span>0x0123456789abcdef<span class="hljs-meta">julia&gt;</span><span class="julia"> typeof(ans)</span>UInt64<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">0x11112222333344445555666677778888</span></span>0x11112222333344445555666677778888<span class="hljs-meta">julia&gt;</span><span class="julia"> typeof(ans)</span>UInt128</code></pre><p>16进制输入的数字最终都会被系统解释为无符号的类型。<br>这是因为16进制输入一般都不是表示数值，而是一个数字序列。</p><p><strong>注意：</strong><code>ans</code><strong>只有在交互模式下可以如此使用</strong></p><h3 id="2进制，8进制"><a href="#2进制，8进制" class="headerlink" title="2进制，8进制"></a>2进制，8进制</h3><p>16进制是允许的，那么2进制和8进制当然也是可以的：</p><pre><code class="language-julia-repl hljs"><span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">0b10</span></span>0x02<span class="hljs-meta">julia&gt;</span><span class="julia"> typeof(ans)</span>UInt8<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">0o010</span></span>0x08<span class="hljs-meta">julia&gt;</span><span class="julia"> typeof(ans)</span>UInt8<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">0x00000000000000001111222233334444</span></span>0x00000000000000001111222233334444<span class="hljs-meta">julia&gt;</span><span class="julia"> typeof(ans)</span>UInt128</code></pre><ul><li>二进制的表示方式:<code>0b</code>开头，每一位只能是<code>0-1</code></li><li>二进制的表示方式:<code>0o</code>开头，每一位只能是<code>0-7</code></li></ul><p>与16进制相同2进制和8进制的输入，系统也是按照无符号类型处理的。<br>处理输入的2进制或者8进制的位数时则是选择能保存该数值的最小位数，开头的0将会被省略（这样可以节约内存空间），如果想保存原始位数，那么使用1开头即可。<br>如果输入数字不能被<code>UInt128</code>存储下，那么这个字面值不合法。<br>如果输入的2，8，16进制数字前面有符号，那么将会转换成无符号的对应值存储：</p><pre><code class="language-julia-repl hljs"><span class="hljs-meta">julia&gt;</span><span class="julia"> -<span class="hljs-number">0x2</span></span>0xfe<span class="hljs-meta">julia&gt;</span><span class="julia"> -<span class="hljs-number">0x0002</span></span>0xfffe</code></pre><h3 id="typemin函数-typemax函数"><a href="#typemin函数-typemax函数" class="headerlink" title="typemin函数,typemax函数"></a><code>typemin</code>函数,<code>typemax</code>函数</h3><p>如果想获得某类型的最大最小值，那么就可以使用<code>typemin</code>函数,<code>typemax</code>函数：</p><pre><code class="language-julia-repl hljs"><span class="hljs-meta">julia&gt;</span><span class="julia"> (typemin(<span class="hljs-built_in">Int32</span>), typemax(<span class="hljs-built_in">Int32</span>))</span>(-2147483648, 2147483647)<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-keyword">for</span> T <span class="hljs-keyword">in</span> [<span class="hljs-built_in">Int8</span>,<span class="hljs-built_in">Int16</span>,<span class="hljs-built_in">Int32</span>,<span class="hljs-built_in">Int64</span>,<span class="hljs-built_in">Int128</span>,<span class="hljs-built_in">UInt8</span>,<span class="hljs-built_in">UInt16</span>,<span class="hljs-built_in">UInt32</span>,<span class="hljs-built_in">UInt64</span>,<span class="hljs-built_in">UInt128</span>]           prIntln(<span class="hljs-string">"<span class="hljs-subst">$(lpad(T,<span class="hljs-number">7</span>)</span>): [<span class="hljs-subst">$(typemin(T)</span>),<span class="hljs-subst">$(typemax(T)</span>)]"</span>)       <span class="hljs-keyword">end</span></span>   Int8: [-128,127]  Int16: [-32768,32767]  Int32: [-2147483648,2147483647]  Int64: [-9223372036854775808,9223372036854775807] Int128: [-170141183460469231731687303715884105728,170141183460469231731687303715884105727]  UInt8: [0,255] UInt16: [0,65535] UInt32: [0,4294967295] UInt64: [0,18446744073709551615]UInt128: [0,340282366920938463463374607431768211455]</code></pre><code>for</code>是循环控制关键字<code>prIntln()</code>是打印函数还有一些其他的细节，我们还没有学习，具体的用法我们将在后面介绍。**注意：<code>typemin</code>函数,<code>typemax</code>函数只支持已经数值类型**### 溢出特性对于有限位数的数值都会存在溢出的现象，这种现象是由于计算机结构的特性造成的，无法避免，可以当错误看待也可以当特性看待：<pre><code class="language-julia-repl hljs"><span class="hljs-meta">julia&gt;</span><span class="julia"> x = typemax(<span class="hljs-built_in">Int64</span>)</span>9223372036854775807<span class="hljs-meta">julia&gt;</span><span class="julia"> x + <span class="hljs-number">1</span></span>-9223372036854775808<span class="hljs-meta">julia&gt;</span><span class="julia"> x + <span class="hljs-number">1</span> == typemin(<span class="hljs-built_in">Int64</span>)</span>true</code></pre><p>这种溢出现象，可以看做是模运算，模运算也是现计算机的重要特性。<br>在应用中出现溢出是可能的，检测溢出现象也是必须的，或者可以尝试使用更高级的类型<code>BigInt</code> 但是虽然溢出问题可以通过该类型解决，但是效率可能会下降，所以，这里就需要程序员自己平衡了。</p><h3 id="除法错误"><a href="#除法错误" class="headerlink" title="除法错误"></a>除法错误</h3><p>除法错误的根本原因是除数为<code>0</code>,但是这只是其中一种，或者说，这是错误的根基，但是表现出来有以下几种：</p><ul><li><code>div</code>函数中除数是<code>0</code></li><li>最小的负数（typemin(Int32)）除以<code>-1</code></li><li>取模操作的操作数是<code>0</code>也会出现除法错误：</li></ul><pre><code>julia> div(100,0)<font color="ff0000"><b>ERROR: DivideError: Integer division error<b></b></b></font>Stacktrace: [1] div(::Int64, ::Int64) at ./Int.jl:232 [2] top-level scope at none:0julia> div(typemin(Int64),-1)<font color="ff0000"><b>ERROR: DivideError: Integer division error<b></b></b></font>Stacktrace: [1] div(::Int64, ::Int64) at ./Int.jl:232 [2] top-level scope at none:0julia> mod(20,0)<font color="ff0000"><b>ERROR: DivideError: Integer division error<b></b></b></font>Stacktrace: [1] div at ./Int.jl:232 [inlined] [2] fld at ./Int.jl:241 [inlined] [3] mod(::Int64, ::Int64) at ./Int.jl:221 [4] top-level scope at none:0julia> rem(20,0)<font color="ff0000"><b>ERROR: DivideError: Integer division error<b></b></b></font>Stacktrace: [1] rem(::Int64, ::Int64) at ./Int.jl:233 [2] top-level scope at none:0julia></code></pre><p>这里面唯一有问题的就是为什么最小的数字除以<code>-1</code>会出现错误，原因很简单，我们假设我们操作4-bit的有符号数字，那么符号位占一位，我们就有如下表格：</p><table><thead><tr><th>十进制数</th><th>符号位+ 二进制绝对值的表示方式</th><th>ones’ complement</th><th>two’s complement</th></tr></thead><tbody><tr><td>+7</td><td>0111</td><td>表示方式不变</td><td>表示方式不变</td></tr><tr><td>+6</td><td>0110</td><td>表示方式不变</td><td>表示方式不变</td></tr><tr><td>+5</td><td>0101</td><td>表示方式不变</td><td>表示方式不变</td></tr><tr><td>+4</td><td>0100</td><td>表示方式不变</td><td>表示方式不变</td></tr><tr><td>+3</td><td>0011</td><td>表示方式不变</td><td>表示方式不变</td></tr><tr><td>+2</td><td>0010</td><td>表示方式不变</td><td>表示方式不变</td></tr><tr><td>+1</td><td>0001</td><td>表示方式不变</td><td>表示方式不变</td></tr><tr><td>+0</td><td>0000</td><td>表示方式不变</td><td>表示方式不变</td></tr><tr><td>-0</td><td>1000</td><td>1111</td><td>(1)0000</td></tr><tr><td>-1</td><td>1001</td><td>1110</td><td>1111</td></tr><tr><td>-2</td><td>1010</td><td>1101</td><td>1110</td></tr><tr><td>-3</td><td>1011</td><td>1100</td><td>1101</td></tr><tr><td>-4</td><td>1100</td><td>1011</td><td>1100</td></tr><tr><td>-5</td><td>1101</td><td>1010</td><td>1011</td></tr><tr><td>-6</td><td>1110</td><td>1001</td><td>1010</td></tr><tr><td>-7</td><td>1111</td><td>1000</td><td>1001</td></tr><tr><td>-8</td><td>超出4个bit所能表达范围</td><td>超出4个表达范围</td><td>1000</td></tr></tbody></table><p>注：要设计硬件区分符号位，比较绝对值大小。无需设计硬件比较大小，但零存在两种表示方法。<br>较好的解决上述问题<br>。由于零只有一种表达方式，所以，可以比别的方式多表达一个-8.<br>(上表来自百度百科：https://baike.baidu.com/item/补码)<br>由于在操作系统中以补码形式存储有符号数，所以，最小的负数值的绝对值比相应的最大的正数值大1，所以，当他除以-1的时候，结果溢出，故除法抛出错误。</p><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p>整型表示的数字都是整数，现在我们该研究一下小数了，带小数的字面值，用浮点型表示</p><h3 id="常用浮点类型"><a href="#常用浮点类型" class="headerlink" title="常用浮点类型"></a>常用浮点类型</h3><h4 id="Float64"><a href="#Float64" class="headerlink" title="Float64"></a>Float64</h4><p>正常输入不加任何修饰、转化的小数字面值都用 <code>Float64</code> 类型存储</p><pre><code class="language-julia-repl hljs"><span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">1.0</span></span>1.0<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">1.</span></span>1.0<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">0.5</span></span>0.5<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">.5</span></span>0.5<span class="hljs-meta">julia&gt;</span><span class="julia"> -<span class="hljs-number">1.23</span></span>-1.23<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">1e10</span></span>1.0e10<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">2.5e-4</span></span>0.00025</code></pre><h4 id="Float32"><a href="#Float32" class="headerlink" title="Float32"></a>Float32</h4><p>以上这些数字以<code>Float64</code> 形式存储，<code>e</code>就是数学中的科学计数法，如果想用单精度浮点数表示，那么就要在数字中加<code>f0</code> 或者如果已经是科学计数法的数字，用<code>f</code>来来替代<code>e</code>，对于单精度双精度不太了解的同学，可以参考：<a href="https://www.face2ai.com/Math-Numerical-Analysis-0-3-Float/"> 数值分析-浮点数</a>或者google查询更详细的关于浮点数的介绍，Julia中的用法如下：</p><pre><code class="language-julia-repl hljs"><span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">0.5f0</span></span>0.5f0<span class="hljs-meta">julia&gt;</span><span class="julia"> typeof(ans)</span>Float32<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">2.5f-4</span></span>0.00025f0</code></pre><p>转化成<code>Float32</code>的方式如下：</p><pre><code class="language-julia-repl hljs"><span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-built_in">Float32</span>(-<span class="hljs-number">1.5</span>)</span>-1.5f0<span class="hljs-meta">julia&gt;</span><span class="julia"> typeof(ans)</span>Float32</code></pre><h4 id="Float16"><a href="#Float16" class="headerlink" title="Float16"></a>Float16</h4><p><code>Float16</code>当然也是支持的，虽然可能使用不多，但是有时候在要在更小的内存设备上使用一些数字16位类型就派上用场了，但是注意，在计算的时候，16位的浮点数会被补全成32位的Float32进行计算，这是因为硬件上的浮点数加法器，乘法器，一般都是32位或者更高的，16位已经退出历史舞台了</p><pre><code class="language-julia-repl hljs"><span class="hljs-meta">julia&gt;</span><span class="julia"> sizeof(<span class="hljs-built_in">Float16</span>(<span class="hljs-number">4.</span>))</span>2<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">2</span>*<span class="hljs-built_in">Float16</span>(<span class="hljs-number">4.</span>)</span>Float16(8.0)</code></pre><p>16 位的<code>Float16</code>占两个字节，共16位<br><code>sizeof()</code> 函数用来计算变量在内存中使用的空间，等效于c/c++ 中的 sizeof()。</p><h4 id="下划线-‘-’"><a href="#下划线-‘-’" class="headerlink" title="下划线 ‘_’"></a>下划线 ‘_’</h4><p>在数字中，下划线在数字中间以分隔符的作用出现，就像我们平时写论文或者写其他比较正式的文章的时候，超过三位的数字，会没三位加逗号，这个逗号在程序里被改成了下划线</p><pre><code class="language-julia-repl hljs"><span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">10_000</span>, <span class="hljs-number">0.000_000_005</span>, <span class="hljs-number">0xdead_beef</span>, <span class="hljs-number">0b1011_0010</span></span>(10000, 5.0e-9, 0xdeadbeef, 0xb2)</code></pre><h3 id="0的浮点数"><a href="#0的浮点数" class="headerlink" title="0的浮点数"></a>0的浮点数</h3><p>浮点数的0有两种表示方法：</p><pre><code class="language-julia-repl hljs"><span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">0.0</span> == -<span class="hljs-number">0.0</span></span>true<span class="hljs-meta">julia&gt;</span><span class="julia"> bitstring(<span class="hljs-number">0.0</span>)</span>"0000000000000000000000000000000000000000000000000000000000000000"<span class="hljs-meta">julia&gt;</span><span class="julia"> bitstring(-<span class="hljs-number">0.0</span>)</span>"1000000000000000000000000000000000000000000000000000000000000000"</code></pre><p>正负0相等，但是浮点的二进制形式差一个符号位。<br><code>bitstring</code> 函数的作用是将变量在内存中的二进制形式按位形成一个字符串。</p><h3 id="特殊的浮点数"><a href="#特殊的浮点数" class="headerlink" title="特殊的浮点数"></a>特殊的浮点数</h3><p>有三个特殊的标准浮点值，这三个值在实数轴上没有对应点，可能大家已经猜到了， $\pm \infty$ 还有就是 “not a number”</p><table><tbody><tr><th><code>Float16</code></th><th><code>Float32</code></th><th><code>Float64</code></th><th>Name</th><th>Description</th></tr><tr><td><code>Inf16</code></td><td><code>Inf32</code></td><td><code>Inf</code></td><td>正无穷</td><td>大于所有能表示出来的浮点数值</td></tr><tr><td><code>-Inf16</code></td><td><code>-Inf32</code></td><td><code>-Inf</code></td><td>负无穷</td><td>小于所有能表示出来的浮点数值</td></tr><tr><td><code>NaN16</code></td><td><code>NaN32</code></td><td><code>NaN</code></td><td>不是一个数字</td><td>结果不等于任何一个浮点数字</td></tr></tbody></table><p>上表就是<code>Float16</code>、<code>Float64</code>、<code>Float32</code> 对应的无穷和Nan的表格，这三个非标准浮点数会经常出现在编程中，尤其是有bug的地方。<br>更多相关内容我们会在后面 “Numeric Comparisons” 中介绍。<br>IEEE 754 标准规定包含特殊浮点数的计算结果如下：</p><pre><code class="language-julia-repl hljs"><span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">1</span>/<span class="hljs-literal">Inf</span></span>0.0<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">1</span>/<span class="hljs-number">0</span></span>Inf<span class="hljs-meta">julia&gt;</span><span class="julia"> -<span class="hljs-number">5</span>/<span class="hljs-number">0</span></span>-Inf<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">0.000001</span>/<span class="hljs-number">0</span></span>Inf<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">0</span>/<span class="hljs-number">0</span></span>NaN<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">500</span> + <span class="hljs-literal">Inf</span></span>Inf<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">500</span> - <span class="hljs-literal">Inf</span></span>-Inf<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-literal">Inf</span> + <span class="hljs-literal">Inf</span></span>Inf<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-literal">Inf</span> - <span class="hljs-literal">Inf</span></span>NaN<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-literal">Inf</span> * <span class="hljs-literal">Inf</span></span>Inf<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-literal">Inf</span> / <span class="hljs-literal">Inf</span></span>NaN<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">0</span> * <span class="hljs-literal">Inf</span></span>NaN</code></pre><p><code>typemin()</code> 和 <code>typemax()</code> 函数可以用于浮点类型，结果如下：</p><pre><code class="language-julia-repl hljs"><span class="hljs-meta">julia&gt;</span><span class="julia"> (typemin(<span class="hljs-built_in">Float16</span>),typemax(<span class="hljs-built_in">Float16</span>))</span>(-Inf16, Inf16)<span class="hljs-meta">julia&gt;</span><span class="julia"> (typemin(<span class="hljs-built_in">Float32</span>),typemax(<span class="hljs-built_in">Float32</span>))</span>(-Inf32, Inf32)<span class="hljs-meta">julia&gt;</span><span class="julia"> (typemin(<span class="hljs-built_in">Float64</span>),typemax(<span class="hljs-built_in">Float64</span>))</span>(-Inf, Inf)</code></pre><h3 id="机器精度（eps-函数）"><a href="#机器精度（eps-函数）" class="headerlink" title="机器精度（eps 函数）"></a>机器精度（<code>eps</code> 函数）</h3><p>大多数实数是不能用机器数准确表达的，所以这就涉及到精度问题，本站<a href="https://www.face2ai.com/categories/Mathematic/Numerical-Analysis/">数值分析</a>主要研究这方面内容，而每种浮点类型的误差已经在其设计时就已经被确定了，当我们要用到相关的准确度的时候，只需要查询语言内置的函数就可以，这属于系统误差，一直都在，如果这个误差影响了程序，那么就要通过数值分析来找办法，<code>eps</code> 函数就是语言内置的查询精度值的函数。</p><h4 id="eps-Float"><a href="#eps-Float" class="headerlink" title="eps(Float)"></a><code>eps(Float)</code></h4><p>其参数是浮点类型时，结果如下：</p><pre><code class="language-julia-repl hljs"><span class="hljs-meta">julia&gt;</span><span class="julia"> eps(<span class="hljs-built_in">Float32</span>)</span>1.1920929f-7<span class="hljs-meta">julia&gt;</span><span class="julia"> eps(<span class="hljs-built_in">Float64</span>)</span>2.220446049250313e-16<span class="hljs-meta">julia&gt;</span><span class="julia"> eps() <span class="hljs-comment"># same as eps(Float64)</span></span>2.220446049250313e-16</code></pre>[ 数值分析-浮点数](https://www.face2ai.com/Math-Numerical-Analysis-0-3-Float/)文中有介绍这个精确度是怎么计算出来的。这个精度的字面定义是 浮点数 1.0和与他最近的另一个该类型的浮点数之间的差。#### <code>eps(100.0)</code><code>eps</code> 函数也能接受浮点数作为参数：<pre><code class="language-julia-repl hljs"><span class="hljs-meta">julia&gt;</span><span class="julia"> eps(<span class="hljs-number">1.0</span>)</span>2.220446049250313e-16<span class="hljs-meta">julia&gt;</span><span class="julia"> eps(<span class="hljs-number">1000.</span>)</span>1.1368683772161603e-13<span class="hljs-meta">julia&gt;</span><span class="julia"> eps(<span class="hljs-number">1e-27</span>)</span>1.793662034335766e-43<span class="hljs-meta">julia&gt;</span><span class="julia"> eps(<span class="hljs-number">0.0</span>)</span>5.0e-324</code></pre><p>当<code>eps</code> 函数以浮点数作为输入的时候，结果是输入的浮点数与最接近的他的浮点数之间的差。</p><h4 id="prevfolat-和nextfloat-函数"><a href="#prevfolat-和nextfloat-函数" class="headerlink" title="prevfolat()和nextfloat()函数"></a><code>prevfolat()</code>和<code>nextfloat()</code>函数</h4><p>使用上面<code>eps</code> 函数的结果可以计算出当前浮点数的最近的上一个浮点数和下一个浮点数：</p><pre><code class="language-julia-repl hljs"><span class="hljs-meta">julia&gt;</span><span class="julia"> x = <span class="hljs-number">1.25f0</span></span>1.25f0<span class="hljs-meta">julia&gt;</span><span class="julia"> nextfloat(x)</span>1.2500001f0<span class="hljs-meta">julia&gt;</span><span class="julia"> prevfloat(x)</span>1.2499999f0<span class="hljs-meta">julia&gt;</span><span class="julia"> bitstring(prevfloat(x))</span>"00111111100111111111111111111111"<span class="hljs-meta">julia&gt;</span><span class="julia"> bitstring(x)</span>"00111111101000000000000000000000"<span class="hljs-meta">julia&gt;</span><span class="julia"> bitstring(nextfloat(x))</span>"00111111101000000000000000000001"</code></pre><p>相邻的浮点数的背后是相邻的二进制机器数，二进制的特性导致了浮点数误差的性质，而我们经常忽视这些误差，这明显是不对的，这么小小的误差就会导致火箭会坠毁。</p><h4 id="“近似”-模型"><a href="#“近似”-模型" class="headerlink" title="“近似” 模型"></a>“近似” 模型</h4><p>当我们的字面值没有对应的准确浮点表达的时候，我们就要进行近似了 —— 向上取近似还是向下取近似。IEEE 754标准有明确的相关的操作。<br><code>RoundNearest</code>对这个过程进行操作，在进阶部分我们会对其过程进行剖析。</p><h4 id="背景知识和引用"><a href="#背景知识和引用" class="headerlink" title="背景知识和引用"></a>背景知识和引用</h4><ul><li>The definitive guide to floating point arithmetic is the <a href="http://standards.ieee.org/findstds/standard/754-2008.html" target="_blank" rel="noopener">IEEE 754-2008 Standard</a>; however, it is not available for free online.</li><li>For a brief but lucid presentation of how floating-point numbers are represented, see John D. Cook’s <a href="https://www.johndcook.com/blog/2009/04/06/anatomy-of-a-floating-point-number/" target="_blank" rel="noopener">article</a> on the subject as well as his <a href="https://www.johndcook.com/blog/2009/04/06/numbers-are-a-leaky-abstraction/" target="_blank" rel="noopener">introduction</a> to some of the issues arising from how this representation differs in behavior from the idealized abstraction of real numbers.</li><li>Also recommended is Bruce Dawson’s <a href="https://randomascii.wordpress.com/2012/05/20/thats-not-normalthe-performance-of-odd-floats/" target="_blank" rel="noopener">series of blog posts on floating-point numbers</a>.</li><li>For an excellent, in-depth discussion of floating-point numbers and issues of numerical accuracy encountered when computing with them, see David Goldberg’s paper <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.22.6768&amp;rep=rep1&amp;type=pdf" target="_blank" rel="noopener">What Every Computer Scientist Should Know About Floating-Point Arithmetic</a>.</li><li>For even more extensive documentation of the history of, rationale for, and issues with floating-point numbers, as well as discussion of many other topics in numerical computing, see the <a href="https://people.eecs.berkeley.edu/~wkahan/" target="_blank" rel="noopener">collected writings</a> of <a href="https://en.wikipedia.org/wiki/William_Kahan" target="_blank" rel="noopener">William Kahan</a>, commonly known as the “Father of Floating-Point”. Of particular interest may be <a href="https://people.eecs.berkeley.edu/~wkahan/ieee754status/754story.html" target="_blank" rel="noopener">An Interview with the Old Man of Floating-Point</a>.</li></ul><h2 id="任意准确度数字"><a href="#任意准确度数字" class="headerlink" title="任意准确度数字"></a>任意准确度数字</h2><p>以上我们研究的数字都受到设计时的精度限制，Julia提供一种不限制大小的数字表达方式，换句话说，这种精度是自定义的，和你输入的数字永远一致，听起来更像把数字字符串化，看起来类似，但是这些字符串是可以进行计算的，Julia打包了GMP(GNU Multiple Precision Arithmetic Library)协议和GNU MPER Library 开发出了 <code>BigInt</code>和<code>BigFloat</code>类型，这两个类型可以表示任意精度的整数或浮点数。<br><code>parse</code>函数提供了将字符串转化成<code>BigInt</code>和<code>BigFloat</code>类型的一种方式，为什么要用这个函数，因为你没办法用其他数值类型保存任意长度的数字，这样操作，一旦<code>BigInt</code>和<code>BigFloat</code>类型的数字完成定义就可以和任意类型的数字进行计算了，这要归功于Julia的内部类型转换机制（后面进阶部分会介绍）</p><pre><code class="language-julia-repl hljs"><span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-built_in">BigInt</span>(typemax(<span class="hljs-built_in">Int64</span>)) + <span class="hljs-number">1</span></span>9223372036854775808<span class="hljs-meta">julia&gt;</span><span class="julia"> parse(<span class="hljs-built_in">BigInt</span>, <span class="hljs-string">"123456789012345678901234567890"</span>) + <span class="hljs-number">1</span></span>123456789012345678901234567891<span class="hljs-meta">julia&gt;</span><span class="julia"> parse(<span class="hljs-built_in">BigFloat</span>, <span class="hljs-string">"1.23456789012345678901"</span>)</span>1.234567890123456789010000000000000000000000000000000000000000000000000000000004<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-built_in">BigFloat</span>(<span class="hljs-number">2.0</span>^<span class="hljs-number">66</span>) / <span class="hljs-number">3</span></span>2.459565876494606882133333333333333333333333333333333333333333333333333333333344e+19<span class="hljs-meta">julia&gt;</span><span class="julia"> factorial(<span class="hljs-built_in">BigInt</span>(<span class="hljs-number">40</span>))</span>815915283247897734345611269596115894272000000000</code></pre><p>虽然可以进行<code>BigInt</code>和<code>BigFloat</code>类型和常规类型的数值计算的时候，Julia会自己进行类型转换，但是如果操作中没有<code>BigInt</code>和<code>BigFloat</code>类型则还是会产生溢出，即当计算式中没有<code>BigInt</code>或<code>BigFloat</code>类型Julia不会自动的调整数值到<code>BigInt</code>或<code>BigFloat</code>类型：</p><pre><code class="language-julia-repl hljs"><span class="hljs-meta">julia&gt;</span><span class="julia"> x = typemin(<span class="hljs-built_in">Int64</span>)</span>-9223372036854775808<span class="hljs-meta">julia&gt;</span><span class="julia"> x = x - <span class="hljs-number">1</span></span>9223372036854775807<span class="hljs-meta">julia&gt;</span><span class="julia"> typeof(x)</span>Int64<span class="hljs-meta">julia&gt;</span><span class="julia"> y = <span class="hljs-built_in">BigInt</span>(typemin(<span class="hljs-built_in">Int64</span>))</span>-9223372036854775808<span class="hljs-meta">julia&gt;</span><span class="julia"> y = y - <span class="hljs-number">1</span></span>-9223372036854775809<span class="hljs-meta">julia&gt;</span><span class="julia"> typeof(y)</span>BigInt</code></pre>常规类型的数字计算还是会溢出。前面提到的近似模型，在BigFloat中将会被改变，其可以被手工指定，利用<code>setprecision</code> 和 <code>setrounding</code> 函数可以进行全局设置。或者如果只想在某个代码块内改变近似模型，则可以使用<code>do</code> 代码块：<pre><code class="language-julia-repl hljs"><span class="hljs-meta">julia&gt;</span><span class="julia"> setrounding(<span class="hljs-built_in">BigFloat</span>, <span class="hljs-literal">RoundUp</span>) <span class="hljs-keyword">do</span>           <span class="hljs-built_in">BigFloat</span>(<span class="hljs-number">1</span>) + parse(<span class="hljs-built_in">BigFloat</span>, <span class="hljs-string">"0.1"</span>)       <span class="hljs-keyword">end</span></span>1.100000000000000000000000000000000000000000000000000000000000000000000000000003<span class="hljs-meta">julia&gt;</span><span class="julia"> setrounding(<span class="hljs-built_in">BigFloat</span>, <span class="hljs-literal">RoundDown</span>) <span class="hljs-keyword">do</span>           <span class="hljs-built_in">BigFloat</span>(<span class="hljs-number">1</span>) + parse(<span class="hljs-built_in">BigFloat</span>, <span class="hljs-string">"0.1"</span>)       <span class="hljs-keyword">end</span></span>1.099999999999999999999999999999999999999999999999999999999999999999999999999986<span class="hljs-meta">julia&gt;</span><span class="julia"> setprecision(<span class="hljs-number">40</span>) <span class="hljs-keyword">do</span>           <span class="hljs-built_in">BigFloat</span>(<span class="hljs-number">1</span>) + parse(<span class="hljs-built_in">BigFloat</span>, <span class="hljs-string">"0.1"</span>)       <span class="hljs-keyword">end</span></span>1.1000000000004</code></pre><h2 id="数字系数"><a href="#数字系数" class="headerlink" title="数字系数"></a>数字系数</h2><h3 id="数值作为系数"><a href="#数值作为系数" class="headerlink" title="数值作为系数"></a>数值作为系数</h3><p>在其他编程语言中，数字变量就是一个操作数，当他作为式子的参数的时候，必须要用操作符连接，比如在c++或者python中我们想表达 $y=2x+1$ 这个表达式的时候一定是:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y=<span class="number">2</span>*x+<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>但是在Julia中数字参数可以用另一种形式表示，回归到其参数的地位，而不是c++或者python中的操作数的身份，在Julia中，数字参数可以这么写：</p><pre><code class="language-julia-repl hljs"><span class="hljs-meta">julia&gt;</span><span class="julia"> x = <span class="hljs-number">3</span></span>3<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">2</span>x^<span class="hljs-number">2</span> - <span class="hljs-number">3</span>x + <span class="hljs-number">1</span></span>10<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">1.5</span>x^<span class="hljs-number">2</span> - <span class="hljs-number">.5</span>x + <span class="hljs-number">1</span></span>13.0</code></pre><p>虽然就差一个操作符号，但是这种系数形式更加贴近原始公式，当然这里交换律不行，不能把数字放到后面，那样就成了一个新的变量了：</p><pre><code>julia> x=22julia> y=2x+15julia> y=x2+1<b><font color="ff0000">ERROR: UndefVarError: x2 not defined</font></b>Stacktrace: [1] top-level scope at none:0julia></code></pre>以下形式表示 $2^{2x}$ 而不是 $2^2x$<pre><code class="language-julia-repl hljs">julia> x=33julia> 2^2x64</code></pre><p>这种表达的一个问题就是我们将会对结合顺序产生疑惑，比如：</p><ul><li><code>-2x</code> 表示<code>(-2)x</code></li><li><code>√2x</code>是表示 <code>(√2)x</code></li><li><code>2x^3</code>是表示 <code>2*(x^3)</code></li></ul><p>前两个比较好理解，对于幂，系数的结合方式类似于一元操作符，比如 <code>-x^2</code>大家都会理解为<code> -(x^2)</code> 这里的符号和系数的语法上的解释是一样的</p><div class="note info"><p>注意：数值系数操作(乘法)优先级高于其他二元操作，比如乘法或者除法：</p><ul><li><code>1 / 2im == -0.5im</code> 而不是<code>0.5im</code></li><li><code>6 // 2(2 + 1) == 1 // 1</code> 而不是 <code>(6 // 2)*3 = 9</code></li></ul></div><h3 id="加了括号的表达式也可以作为系数"><a href="#加了括号的表达式也可以作为系数" class="headerlink" title="加了括号的表达式也可以作为系数"></a>加了括号的表达式也可以作为系数</h3><p>加了括号的表达式可以作为系数，比如：</p><pre><code class="language-julia-repl hljs"><span class="hljs-meta">julia&gt;</span><span class="julia"> (x-<span class="hljs-number">1</span>)x</span>6</code></pre><p>但是没有加括号的表达式，或者两个操作数都有括号，就不可以这么写了：</p><pre><code class="language-julia-repl hljs"><span class="hljs-meta">julia&gt;</span><span class="julia"> (x-<span class="hljs-number">1</span>)(x+<span class="hljs-number">1</span>)</span>ERROR: MethodError: objects of type Int64 are not callable<span class="hljs-meta">julia&gt;</span><span class="julia"> x(x+<span class="hljs-number">1</span>)</span>ERROR: MethodError: objects of type Int64 are not callable</code></pre><p>上面这两种写法报错的原因是，这两种写法和函数的写法撞车了，所以不可能允许这种计算。</p><p>上面这两种写法给我们写公式的时候带来了很大的方便，注意不要在系数后面加空格，也不要在括号系数后加空格。</p><h3 id="句法争议"><a href="#句法争议" class="headerlink" title="句法争议"></a>句法争议</h3><p>上面的参数写法不被其他语言采纳的原因是会造成其他句法混淆，比如十六进制和科学计数法：</p><ul><li>十六进制数字 <code>0xff</code> 将会被解释成：参数 <code>0</code> 乘以变量 <code>xff</code>.</li><li>浮点数 <code>1e10</code>会被解释成：参数 <code>1</code> 乘以变量 <code>e10</code>， <code>E</code>形式类似</li><li>32位浮点数 <code>1.5f22</code> 被解释为：参数<code>1.5</code> 乘以变量<code>f22</code>.</li></ul><p>对于上述争端，Julia给出的解释是：</p><ul><li><code>0x</code>被解释为16进制字符，不会被理解成别的</li><li>一个数字后面跟了 <code>e</code> 或者 <code>E</code> 将会被解释为浮点数</li><li>一个数字后面跟了 <code>f</code>将会被解释为32-bit浮点数，<strong>但是F不会被解释为32-bit浮点数，而是按照系数解释</strong></li></ul><h2 id="“清零”-和-“归一”"><a href="#“清零”-和-“归一”" class="headerlink" title="“清零” 和 “归一”"></a>“清零” 和 “归一”</h2><p>Julia提供了一个函数来产生0，和1，这个作用听起来有点费解，这不就是赋值么？为什么还要函数，因为不同的数值类型对应着不同的0的表示法，比如不同长度的浮点数的0就有很多种，所以一个函数搞定还是方便的：</p><table><tbody><tr><th>Function</th><th>Description</th></tr><tr><td><a href="../../base/numbers/#Base.zero"><code>zero(x)</code></a></td><td>Literal zero of type <code>x</code> or type of variable <code>x</code></td></tr><tr><td><a href="../../base/numbers/#Base.one"><code>one(x)</code></a></td><td>Literal one of type <code>x</code> or type of variable <code>x</code></td></tr></tbody></table><p>其操作结果：</p><pre><code class="language-julia-repl hljs"><span class="hljs-meta">julia&gt;</span><span class="julia"> zero(<span class="hljs-built_in">Float32</span>)</span>0.0f0<span class="hljs-meta">julia&gt;</span><span class="julia"> zero(<span class="hljs-number">1.0</span>)</span>0.0<span class="hljs-meta">julia&gt;</span><span class="julia"> one(<span class="hljs-built_in">Int32</span>)</span>1<span class="hljs-meta">julia&gt;</span><span class="julia"> one(<span class="hljs-built_in">BigFloat</span>)</span>1.0</code></pre><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li><a href="https://docs.julialang.org/en/v1/manual/integers-and-floating-point-numbers/" target="_blank" rel="noopener">https://docs.julialang.org/en/v1/manual/integers-and-floating-point-numbers/</a></li></ol><hr><p><a href="https://face2ai.com/Julia-Lang-4-Integers-and-Floating-PoInt-Numbers" target="_blank" rel="noopener">原文地址: https://face2ai.com/Julia-Lang-4-Integers-and-Floating-PoInt-Numbers</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; 本文介绍Julia语言的整型和浮点型数字的&lt;br&gt;&lt;strong&gt;Keywords:&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Julia" scheme="http://www.face2ai.com/categories/Julia/"/>
    
      <category term="Freshman" scheme="http://www.face2ai.com/categories/Julia/Freshman/"/>
    
    
      <category term="Julia" scheme="http://www.face2ai.com/tags/Julia/"/>
    
      <category term="浮点型数字" scheme="http://www.face2ai.com/tags/%E6%B5%AE%E7%82%B9%E5%9E%8B%E6%95%B0%E5%AD%97/"/>
    
      <category term="整型数字" scheme="http://www.face2ai.com/tags/%E6%95%B4%E5%9E%8B%E6%95%B0%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>【强化学习】1.6 本章总结、强化学习历史简述</title>
    <link href="http://www.face2ai.com/RL-RSAB-1-6-Summary-History/"/>
    <id>http://www.face2ai.com/RL-RSAB-1-6-Summary-History/</id>
    <published>2018-10-02T08:56:30.000Z</published>
    <updated>2018-10-07T09:11:25.905Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Abstract:</strong> 强化学习第一章小结<br><strong>Keywords:</strong> 强化学习历史，强化学习总结<br><a id="more"></a></p><h1 id="本章总结、强化学习历史简述"><a href="#本章总结、强化学习历史简述" class="headerlink" title="本章总结、强化学习历史简述"></a>本章总结、强化学习历史简述</h1><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>强化学习就是一种通过计算方式来理解和进行目标导向学习的方法。其直接表现是通过agent和环境的交互进行学习，而不需要对环境做任何限制或者需要复杂的环境模型，从本书作者来看，强化学习是第一个研究agent在和环境交互的时候产生的问题计算化的领域，通过研究和环境的交互，达到长期的目标。<br>强化学习有一个非常明显的框架，就是agent和环境之间的action、state和reward之间的相互关系。这个框架尝试着从一种简单的方式来反应人工智能问题的基本特点，而这些特点包括：“诱因”（cause） 和 “结果”（effect），“不确定”（uncertainty）和 “非决定论”（nondeterminism） 以及 “清晰目标的存在性”（existence of explicit goal）。</p><h2 id="强化学习历史"><a href="#强化学习历史" class="headerlink" title="强化学习历史"></a>强化学习历史</h2><p>强化学习的历史不是很久远，但是由于研究的方向很多，所以没办法把每条只限都列举出来，这里我们主要分成三个方向：</p><ol><li>研究 “trial” 和 “error”<ul><li>起源于早期对动物学习的研究</li><li>早期人工智能的主要方向</li><li>1980s强化学习复苏的主要动力</li></ul></li><li>优化控制<ul><li>使用 <strong>value function</strong> 求解</li><li>使用 <strong>dynamic programming</strong> 求解</li></ul></li><li>1和2的混合<ul><li>1和2看起来相互独立，而且独立程度很高，但是我们前面说到的井字棋中使用到了“<a href="https://face2ai.com/RL-RSAB-1-5-An-Extended-Example/" target="_blank" rel="noopener">时序差分方法</a>”（temporal-difference method）</li></ul></li></ol><p>相关论文见引用1中的1.7节</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol><li>Sutton R S, Barto A G. Reinforcement learning: An introduction[J]. 2011.</li></ol><hr><p>原文地址:<a href="https://face2ai.com/RL-RSAB-1-6-Summary-History" target="_blank" rel="noopener">https://face2ai.com/RL-RSAB-1-6-Summary-History</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; 强化学习第一章小结&lt;br&gt;&lt;strong&gt;Keywords:&lt;/strong&gt; 强化学习历史，强化学习总结&lt;br&gt;
    
    </summary>
    
      <category term="Reinforcement Learning" scheme="http://www.face2ai.com/categories/Reinforcement-Learning/"/>
    
      <category term="RL-An Introduction" scheme="http://www.face2ai.com/categories/Reinforcement-Learning/RL-An-Introduction/"/>
    
    
      <category term="强化学习" scheme="http://www.face2ai.com/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>【Julia】变量</title>
    <link href="http://www.face2ai.com/Julia-Lang-3-Variables/"/>
    <id>http://www.face2ai.com/Julia-Lang-3-Variables/</id>
    <published>2018-10-02T01:13:40.000Z</published>
    <updated>2018-10-04T14:59:51.538Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Abstract:</strong> 本文介绍Julia变量的相关内容，包括Julia的变量命名，以及命名的惯用法则（命名风格）<br><strong>Keywords:</strong> Julia变量，Julia变量名，Julia命名一般规则<br><a id="more"></a></p><h1 id="Julia-变量"><a href="#Julia-变量" class="headerlink" title="Julia 变量"></a>Julia 变量</h1><p>如果Julia不是你的入门编程语言，那么对于编程语言中的变量应该已经习以为常，在C语言中，变量名对应于一个内存地址（需要声明变量类型）而在高级一些的语言中，比如python，变量名更抽象，他对应于一个值，或者可以理解为它存储了这个值，这个值可以是该语言允许的任何类型（不需要声明变量类型）。<br>Julia的变量属于后者，不需要声明变量类型，而是可以让你的合法变量名随时存储任何Julia变量类型的值。<br>如果Julia是你的第一门编程语言，那么你只要知道，变量名存储了一个变量值就可以了。<br>在交互模式下，我们进行一下操作，比如输入 <code>x=10</code> 后回车，就会输出10这个结果，接着你可以输入指令 <code>x+1</code> 回车，就会显示 <code>10+1</code> 的结果，如下：</p><pre><code class="language-julia-repl hljs"># Assign the value 10 to the variable x<span class="hljs-meta">julia&gt;</span><span class="julia"> x = <span class="hljs-number">10</span></span>10# Doing math with x's value<span class="hljs-meta">julia&gt;</span><span class="julia"> x + <span class="hljs-number">1</span></span>11# Reassign x's value<span class="hljs-meta">julia&gt;</span><span class="julia"> x = <span class="hljs-number">1</span> + <span class="hljs-number">1</span></span>2# You can assign values of other types, like strings of text<span class="hljs-meta">julia&gt;</span><span class="julia"> x = <span class="hljs-string">"Hello World!"</span></span>"Hello World!"</code></pre><p>任何编译器解释器都不会关心这个变量叫什么名字，所有变量在解释器面前一视同仁，所以你不用担心你的变量名字不好听而影响程序执行效果。<br>接着再看几个例子（例子都来自Julia文档）</p><pre><code class="language-julia-repl hljs"><span class="hljs-meta">julia&gt;</span><span class="julia"> x = <span class="hljs-number">1.0</span></span>1.0<span class="hljs-meta">julia&gt;</span><span class="julia"> y = -<span class="hljs-number">3</span></span>-3<span class="hljs-meta">julia&gt;</span><span class="julia"> Z = <span class="hljs-string">"My string"</span></span>"My string"<span class="hljs-meta">julia&gt;</span><span class="julia"> customary_phrase = <span class="hljs-string">"Hello world!"</span></span>"Hello world!"<span class="hljs-meta">julia&gt;</span><span class="julia"> UniversalDeclarationOfHumanRightsStart = <span class="hljs-string">"人人生而自由，在尊严和权利上一律平等。"</span></span>"人人生而自由，在尊严和权利上一律平等。"</code></pre><p>更厉害的是Julia的变量名不止局限于英文字符的组合，unicode字符通过 UTF-8 编码也可以成为变量，换句话说，希腊字母，中文字符，日文，韩文等这些都可以做变量名，这就厉害了，python 和c/c++ 是不行的：</p><pre><code class="language-julia-repl hljs"><span class="hljs-meta">julia&gt;</span><span class="julia"> δ = <span class="hljs-number">0.00001</span></span>1.0e-5<span class="hljs-meta">julia&gt;</span><span class="julia"> 你好地球 = <span class="hljs-string">"Hello world"</span></span>"Hello world"<span class="hljs-meta">julia&gt;</span><span class="julia"> 안녕하세요 = <span class="hljs-string">"Hello"</span></span>"Hello"</code></pre>怎么样，可以用中文命名变量名了以后，你会在你的工程中使用中文命名你的变量名么？注意到上面 $\delta$ 的同学们可能在想这个变量在实际中怎么使用呢？好消息，用latex就可以，当然只有部分编辑器或者IDE支持这个功能，Julia REPL 是支持的，上面的 $\delta$ 在Julia REPL的写法就是 <code>\delta</code>-*tab* ，如果你发现那个字符不知道怎么写，比如你看别人的代码中有个 $\zeta$ 不知道怎么写，你只需要在Julia REPL 中输入 <code>?</code> 然后在后面粘贴那个字符即可。有一些编程语言会为编译器或者编辑器定义一些常量以及函数，这些常量或函数一般不允许用户修改，但是Julia可以，如果你明确知道自己在做什么，那么这个操作可以帮助你的程序更好更符合你想象的方式进行，但是如果你还是个新手，建议不要随意修改内置常量或函数，因为你很有可能忘记自己修改过这个常量或函数，而在别的部分再次当做原始功能使用，就会造成很隐蔽的bug。<pre><code class="language-julia-repl hljs"><span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-literal">pi</span> = <span class="hljs-number">3</span></span>3<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-literal">pi</span></span>3<span class="hljs-meta">julia&gt;</span><span class="julia"> sqrt = <span class="hljs-number">4</span></span>4</code></pre><p>但是如果这个常量或函数先被使用，而你在之后尝试重新定义或者修改，那么Julia就会抛出错误：</p><pre><code class="language-julia-repl hljs"><span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-literal">pi</span></span>π = 3.1415926535897...<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-literal">pi</span> = <span class="hljs-number">3</span></span>ERROR: cannot assign variable MathConstants.pi from module Main<span class="hljs-meta">julia&gt;</span><span class="julia"> sqrt(<span class="hljs-number">100</span>)</span>10.0<span class="hljs-meta">julia&gt;</span><span class="julia"> sqrt = <span class="hljs-number">4</span></span>ERROR: cannot assign variable Base.sqrt from module Main</code></pre><h2 id="Julia-变量命名规则"><a href="#Julia-变量命名规则" class="headerlink" title="Julia 变量命名规则"></a>Julia 变量命名规则</h2><p>变量名的命名规则：<br><div class="note info"><ol><li>变量名以字母 <strong>A-Z or a-z，下划线，或者Unicode中大于00A0的部分</strong> 开头（更过详细的Unicode参考4）</li><li>像 <code>+</code> 这类操作符也是可以用作标识符的，但是这种用法非常特殊，比如再从新定义加法操作的时候，加法操作就是用<code>(+)</code> 来定义的，<code>(+)=f</code> 就是重新定义加法操作（更过详细的Unicode参考4）</li><li>语言内置的状态符是不可以用作变量名的，比如你不可把 <code>if</code>,<code>else</code>这类关键字用作变量名：<pre><code class="language-julia-repl hljs"><span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-keyword">else</span> = <span class="hljs-literal">false</span></span>ERROR: syntax: unexpected "else"<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-keyword">try</span> = <span class="hljs-string">"No"</span></span>ERROR: syntax: unexpected "="</code></pre></li><li>Unicode变量名的有一些注意细节，如果要大量使用，可以参考文档：<a href="https://docs.julialang.org/en/latest/manual/variables/" target="_blank" rel="noopener">https://docs.julialang.org/en/latest/manual/variables/</a></li></ol></div></p><h2 id="Julia-变量名的常用风格"><a href="#Julia-变量名的常用风格" class="headerlink" title="Julia 变量名的常用风格"></a>Julia 变量名的常用风格</h2><p>命名风格不是语法内容，这些内容是一些常见的比较利于编程的习惯，如果你有自己的更好的习惯，也可以用你的方法来写，但是代码的作用一是为了驱动程序，得出我们想要的结果，第二则是让别人了解你的思想，如果大家都看不懂你的什么，那么这个代码其实是不成功的。<br>常见的命名风格有以下几条：</p><ol><li>变量名采用小写字母</li><li>每个单词之间用 <code>_</code> 分开，但一般不要使用，除非这个变量名特别长，且不好读。</li><li><code>Type</code>s或者<code>Module</code>s的名字以大写字母开头，每个单词首字母大写，用驼峰形式代替下划线</li><li><code>function</code>s或者<code>macro</code>s用小写形式，不要使用下划线。</li><li><code>function</code>如果要对其参数进行写的操作的话，函数名后面要加<code>!</code>，这种函数叫做 “变异函数”(mutating)或者“取代函数”(in-place)因为这种函数不只返回一个结果，还会在过程中修改参数的值。</li><li>更多编程风格可以参考<a href="https://docs.julialang.org/en/latest/manual/style-guide/" target="_blank" rel="noopener">https://docs.julialang.org/en/latest/manual/style-guide/</a></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了Julia变量和简单的命名风格，好的编程风格是很重要的，无论对于编码还是调试。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li><a href="https://docs.julialang.org/en/latest/manual/variables/" target="_blank" rel="noopener">https://docs.julialang.org/en/latest/manual/variables/</a></li></ol><hr><p><a href="https://face2ai.com/Julia-Lang-3-Variables" target="_blank" rel="noopener">原文地址: https://face2ai.com/Julia-Lang-3-Variables</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; 本文介绍Julia变量的相关内容，包括Julia的变量命名，以及命名的惯用法则（命名风格）&lt;br&gt;&lt;strong&gt;Keywords:&lt;/strong&gt; Julia变量，Julia变量名，Julia命名一般规则&lt;br&gt;
    
    </summary>
    
      <category term="Julia" scheme="http://www.face2ai.com/categories/Julia/"/>
    
      <category term="Freshman" scheme="http://www.face2ai.com/categories/Julia/Freshman/"/>
    
    
      <category term="Julia" scheme="http://www.face2ai.com/tags/Julia/"/>
    
      <category term="Julia变量" scheme="http://www.face2ai.com/tags/Julia%E5%8F%98%E9%87%8F/"/>
    
      <category term="Julia变量名" scheme="http://www.face2ai.com/tags/Julia%E5%8F%98%E9%87%8F%E5%90%8D/"/>
    
      <category term="Julia命名一般规则" scheme="http://www.face2ai.com/tags/Julia%E5%91%BD%E5%90%8D%E4%B8%80%E8%88%AC%E8%A7%84%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>【Julia】开始使用Julia</title>
    <link href="http://www.face2ai.com/Julia-Lang-2-Getting-Started/"/>
    <id>http://www.face2ai.com/Julia-Lang-2-Getting-Started/</id>
    <published>2018-10-01T01:16:49.000Z</published>
    <updated>2018-10-04T14:59:45.895Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Abstract:</strong> 本文介绍如何在命令行中开启、使用、退出Julia，如何执行文件，以及执行Julia时候的可选选项（参数列表）<br><strong>Keywords:</strong> Julia，Julia使用，Julia命令行，Julia执行文件<br><a id="more"></a></p><h1 id="开始使用Julia"><a href="#开始使用Julia" class="headerlink" title="开始使用Julia"></a>开始使用Julia</h1><p>本文我们来学习Julia的几种用法，包括便捷的终端交互，以及对于复杂功能的文件执行。</p><h2 id="终端使用Julia-交互模式"><a href="#终端使用Julia-交互模式" class="headerlink" title="终端使用Julia(交互模式)"></a>终端使用Julia(<strong>交互模式</strong>)</h2><p>在终端启动Julia比较简单，上文我们完成了Julia的安装，并在Mac下完成了命令行下启动的设置，那么我们可直接在命令行提示符后输入<code>julia</code> 完成Julia环境的启动（<strong>交互模式</strong>），如果出现下图，表示启动成功了。</p><h3 id="在交互模式下执行命令"><a href="#在交互模式下执行命令" class="headerlink" title="在交互模式下执行命令"></a>在交互模式下执行命令</h3><p>在Julia的命令提示符后输入<code>1 + 2</code> 后回车，就会显示计算结果。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> julia</span></span><br><span class="line"></span><br><span class="line">               _</span><br><span class="line">   _       _ _(_)_     |  Documentation: https://docs.julialang.org</span><br><span class="line">  (_)     | (_) (_)    |</span><br><span class="line">   _ _   _| |_  __ _   |  Type "?" for help, "]?" for Pkg help.</span><br><span class="line">  | | | | | | |/ _` |  |</span><br><span class="line">  | | |_| | | | (_| |  |  Version 1.0.0 (2018-08-08)</span><br><span class="line"> _/ |\__'_|_|_|\__'_|  |</span><br><span class="line">|__/                   |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">julia&gt;</span><span class="bash"> 1 + 2</span></span><br><span class="line">3</span><br><span class="line"></span><br><span class="line"><span class="meta">julia&gt;</span><span class="bash"> ans</span></span><br><span class="line">3</span><br></pre></td></tr></table></figure></p><p><code>ans</code>变量表示上次<strong>计算</strong>的结果，如果在这个<code>ans</code>下再次输入<code>ans</code>并回车，显示结果是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">julia&gt;</span><span class="bash"> 1 + 2</span></span><br><span class="line">3</span><br><span class="line"></span><br><span class="line"><span class="meta">julia&gt;</span><span class="bash"> ans</span></span><br><span class="line">3</span><br><span class="line"></span><br><span class="line"><span class="meta">julia&gt;</span><span class="bash"> ans</span></span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>注意：<code>ans</code>只能在<strong>交互模式</strong>下使用</p><h3 id="在交互模式下执行文件"><a href="#在交互模式下执行文件" class="headerlink" title="在交互模式下执行文件"></a>在交互模式下执行文件</h3><p>如果你有一个julia文件 <code>file.jl</code>，里面写的是计算过程:<br><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>+<span class="number">3</span></span><br></pre></td></tr></table></figure></p><p>你可以在<strong>交互模式</strong>下执行这个文件，使用命令 <code>include(“file.jl”)</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">julia</span></span><br><span class="line">               _</span><br><span class="line">   _       _ _(_)_     |  Documentation: https://docs.julialang.org</span><br><span class="line">  (_)     | (_) (_)    |</span><br><span class="line">   _ _   _| |_  __ _   |  Type "?" for help, "]?" for Pkg help.</span><br><span class="line">  | | | | | | |/ _` |  |</span><br><span class="line">  | | |_| | | | (_| |  |  Version 1.0.0 (2018-08-08)</span><br><span class="line"> _/ |\__'_|_|_|\__'_|  |  Official https://julialang.org/ release</span><br><span class="line">|__/                   |</span><br><span class="line"></span><br><span class="line"><span class="meta">julia&gt;</span><span class="bash"> include(<span class="string">"file.jl"</span>)</span></span><br><span class="line">4</span><br><span class="line"></span><br><span class="line"><span class="meta">julia&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure><h3 id="退出交互模式"><a href="#退出交互模式" class="headerlink" title="退出交互模式"></a>退出交互模式</h3><p>退出交互模式回到终端有两种方法：</p><ol><li><code>CTRL-d</code> linux和windows下同时按下 <code>ctrl</code> 键和<code>d</code> 键</li><li>输入 <code>exit()</code></li></ol><h2 id="终端执行Julia文件"><a href="#终端执行Julia文件" class="headerlink" title="终端执行Julia文件"></a>终端执行Julia文件</h2><p>在终端下执行Julia文件的方式和其他脚本的执行方式类似：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> julia script.jl arg1 arg2...</span></span><br></pre></td></tr></table></figure><p>如果我们执行上面我们说到的 <code>file.jl</code>那么在终端下的执行结果如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> julia file.jl</span></span><br><span class="line"><span class="meta">$</span><span class="bash"></span></span><br></pre></td></tr></table></figure></p><p>没有显示结果，因为我们在文件中只有 <code>1+3</code>这条指令，而没有要求他输出什么，在交互模式下，程序自动显示计算结果，但是在终端下执行脚本，只执行脚本中的命令，而不会自己显示什么。<br>接着我们编辑另一个文件<code>script.jl</code>，内容如下：<br><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="literal">PROGRAM_FILE</span>);</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="literal">ARGS</span>;</span><br><span class="line">    println(x);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>然后我们加上参数，这里是<strong>输入给脚本的参数</strong> —— <code>arg1 arg2 …</code><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> julia script.jl foo bar</span></span><br><span class="line">script.jl</span><br><span class="line">foo</span><br><span class="line">bar</span><br><span class="line"><span class="meta">$</span><span class="bash"></span></span><br></pre></td></tr></table></figure></p><p>这里的三部分分别是 <code>julia</code> (程序名，用于在终端中启动程序，类似于python脚本运行前的python，sh等)、 <code>script.jl</code>（脚本文件名） 以及 <code>foo bar </code>（输入脚本的参数）。</p><h2 id="Julia的参数"><a href="#Julia的参数" class="headerlink" title="Julia的参数"></a>Julia的参数</h2><p>在执行脚本时我们给脚本了两个个参数（<code>foo bar</code>），同时，我们也可以给julia多个参数(上面的例子中 <code>script.jl foo bar</code> 是Julia程序的一个参数 )，加参数方式是在多个参数中间用 <code>–</code> 划分 ,例如上面的例子可以加上如下参数<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">julia --color=yes -O --script.jl foo bar</span><br></pre></td></tr></table></figure></p><p>julia程序包含两个参数，分别是：</p><ul><li><code>–color=yes -O </code></li><li><code>–script.jl foo bar</code></li></ul><p>script.jl 包含两个参数：</p><ul><li><code>foo</code></li><li><code>bar</code></li></ul><h2 id="Julia-的并行模式（本机和集群）"><a href="#Julia-的并行模式（本机和集群）" class="headerlink" title="Julia 的并行模式（本机和集群）"></a>Julia 的并行模式（本机和集群）</h2><p>Julia可以以并行模式启动，启动参数是 <code>-p</code>或者 <code>–machine-file</code><br><code>-p n</code> 将会启动n个工作进程<br><code>–machine-file file</code> 将会按照file中记录的机器地址，启动对应机器上的任务。<br><code>–machine-file</code> 模式注意以下要求：</p><ol><li>这些机器的登录方式必须是<code>ssh</code>无密码登录(不需要输入手工输入密码，而是通过ssh 秘钥登录)</li><li>这些机器上的Julia安装目录必须和当前执行命令的主机位置相同</li><li><code>file</code>中的每一条机器记录格式如下<ul><li><code>[count*][user@]host[:port] [bind_addr[:port]]</code><ul><li><code>count *</code>是节点要执行的工作进程数量（类似本机的-p n）</li><li><code>user</code> 默认是当前用户</li><li><code>port</code> 是标准ssh的端口号，默认是1</li><li><code>bind-to bind_addr[:port]</code> 是其他机器使用的IP地址和端口号，可以用来连接到本机。</li></ul></li></ul></li></ol><h2 id="Julia更多执行参数列表"><a href="#Julia更多执行参数列表" class="headerlink" title="Julia更多执行参数列表"></a>Julia更多执行参数列表</h2><p>Julia的更多参数列表如下，执行方法：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">julia [switches] -- [programfile] [args...]</span><br></pre></td></tr></table></figure></p><p>参数列表：</p><table><tbody><tr><th>Switch</th><th>Description</th></tr><tr><td><code>-v</code>, <code>–version</code></td><td>Display version information</td></tr><tr><td><code>-h</code>, <code>–help</code></td><td>Print this message</td></tr><tr><td><code>-J</code>, <code>–sysimage &lt;file&gt;</code></td><td>Start up with the given system image file</td></tr><tr><td><code>-H</code>, <code>–home &lt;dir&gt;</code></td><td>Set location of <code>julia</code> executable</td></tr><tr><td><code>–startup-file={yes|no}</code></td><td>Load <code>~/.julia/config/startup.jl</code></td></tr><tr><td><code>–handle-signals={yes|no}</code></td><td>Enable or disable Julia’s default signal handlers</td></tr><tr><td><code>–sysimage-native-code={yes|no}</code></td><td>Use native code from system image if available</td></tr><tr><td><code>–compiled-modules={yes|no}</code></td><td>Enable or disable incremental precompilation of modules</td></tr><tr><td><code>-e</code>, <code>–eval &lt;expr&gt;</code></td><td>Evaluate <code>&lt;expr&gt;</code></td></tr><tr><td><code>-E</code>, <code>–print &lt;expr&gt;</code></td><td>Evaluate <code>&lt;expr&gt;</code> and display the result</td></tr><tr><td><code>-L</code>, <code>–load &lt;file&gt;</code></td><td>Load <code>&lt;file&gt;</code> immediately on all processors</td></tr><tr><td><code>-p</code>, <code>–procs {N|auto</code>}</td><td>Integer value N launches N additional local worker processes; <code>auto</code> launches as many workers as the number of local CPU threads (logical cores)</td></tr><tr><td><code>–machine-file &lt;file&gt;</code></td><td>Run processes on hosts listed in <code>&lt;file&gt;</code></td></tr><tr><td><code>-i</code></td><td>Interactive mode; REPL runs and <code>isinteractive()</code> is true</td></tr><tr><td><code>-q</code>, <code>–quiet</code></td><td>Quiet startup: no banner, suppress REPL warnings</td></tr><tr><td><code>–banner={yes|no|auto}</code></td><td>Enable or disable startup banner</td></tr><tr><td><code>–color={yes|no|auto}</code></td><td>Enable or disable color text</td></tr><tr><td><code>–history-file={yes|no}</code></td><td>Load or save history</td></tr><tr><td><code>–depwarn={yes|no|error}</code></td><td>Enable or disable syntax and method deprecation warnings (<code>error</code> turns warnings into errors)</td></tr><tr><td><code>–warn-overwrite={yes|no}</code></td><td>Enable or disable method overwrite warnings</td></tr><tr><td><code>-C</code>, <code>–cpu-target &lt;target&gt;</code></td><td>Limit usage of cpu features up to &lt;target&gt;; set to <code>help</code> to see the available options</td></tr><tr><td><code>-O</code>, <code>–optimize={0,1,2,3}</code></td><td>Set the optimization level (default level is 2 if unspecified or 3 if used without a level)</td></tr><tr><td><code>-g</code>, <code>-g &lt;level&gt;</code></td><td>Enable / Set the level of debug info generation (default level is 1 if unspecified or 2 if used without a level)</td></tr><tr><td><code>–inline={yes|no}</code></td><td>Control whether inlining is permitted, including overriding <code>@inline</code> declarations</td></tr><tr><td><code>–check-bounds={yes|no}</code></td><td>Emit bounds checks always or never (ignoring declarations)</td></tr><tr><td><code>–math-mode={ieee,fast}</code></td><td>Disallow or enable unsafe floating point optimizations (overrides @fastmath declaration)</td></tr><tr><td><code>–code-coverage={none|user|all}</code></td><td>Count executions of source lines</td></tr><tr><td><code>–code-coverage</code></td><td>equivalent to <code>–code-coverage=user</code></td></tr><tr><td><code>–track-allocation={none|user|all}</code></td><td>Count bytes allocated by each source line</td></tr><tr><td><code>–track-allocation</code></td><td>equivalent to <code>–track-allocation=user</code></td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍Julia基础的启动，以及并行模型，执行参数的选择等知识。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li><a href="https://docs.julialang.org/en/v1/manual/getting-started/" target="_blank" rel="noopener">https://docs.julialang.org/en/v1/manual/getting-started/</a></li></ol><hr><p><a href="https://face2ai.com/Julia-Lang-2-Getting-Started" target="_blank" rel="noopener">原文地址: https://face2ai.com/Julia-Lang-2-Getting-Started</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; 本文介绍如何在命令行中开启、使用、退出Julia，如何执行文件，以及执行Julia时候的可选选项（参数列表）&lt;br&gt;&lt;strong&gt;Keywords:&lt;/strong&gt; Julia，Julia使用，Julia命令行，Julia执行文件&lt;br&gt;
    
    </summary>
    
      <category term="Julia" scheme="http://www.face2ai.com/categories/Julia/"/>
    
      <category term="Freshman" scheme="http://www.face2ai.com/categories/Julia/Freshman/"/>
    
    
      <category term="Julia" scheme="http://www.face2ai.com/tags/Julia/"/>
    
      <category term="Julia使用" scheme="http://www.face2ai.com/tags/Julia%E4%BD%BF%E7%94%A8/"/>
    
      <category term="Julia命令行" scheme="http://www.face2ai.com/tags/Julia%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    
      <category term="Julia执行文件" scheme="http://www.face2ai.com/tags/Julia%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>【Julia】Julia环境搭建（Mac,Windows,Linux）</title>
    <link href="http://www.face2ai.com/Julia-Lang-1-Install/"/>
    <id>http://www.face2ai.com/Julia-Lang-1-Install/</id>
    <published>2018-09-29T13:56:02.000Z</published>
    <updated>2018-10-04T14:59:42.824Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Abstract:</strong> 本介绍Julia环境的搭建，包括在Mac，Linux以及在Windows下的安装过程，最后我们使用atom搭建一个Julia IDE<br><strong>Keywords:</strong> Julia环境搭建, Mac,Julia Windows,Julia Linux,Juno<br><a id="more"></a></p><h1 id="Julia环境搭建（Mac-Windows-Linux）"><a href="#Julia环境搭建（Mac-Windows-Linux）" class="headerlink" title="Julia环境搭建（Mac,Windows,Linux）"></a>Julia环境搭建（Mac,Windows,Linux）</h1><p>上文我们说到Julia是一种适合数据科学的语言，那么今天我们就研究一下怎么安装Julia，以及完成一套IDE的搭建，很多人，尤其是写程序有一段时间，但是时间又不长的同学经常会纠结各种问题，比如为啥大牛都用VIM，是不是要学会VIM才能继续进步，说实话，不管是IDE还是VIM还是EMACS，不过是个工具，哪个你用的效率最高哪个就是最好的，至于vim的神话，我的解读是，vim必然是个利器，入了门的人得心应手，但是入门困难的就一直处于困难阶段，我们的最终目的是为了完成我的设计的算法，评估测试算法，至于用什么编辑器，什么环境，我觉得你找个最顺手的，那就是最好的。<br>本文我们用到的编辑器是Atom，因为atom中的插件可以直接把一个编辑器扩展成IDE，如果你是资深vim用户，那么你一定有办法自己把编辑器调整到顺手状态。<br>所以我们今天只讲安装和atom下的IDE搭建。</p><h2 id="安装Julia"><a href="#安装Julia" class="headerlink" title="安装Julia"></a>安装Julia</h2><p>安装Julia并不难，到地址 <a href="https://julialang.org/downloads/" target="_blank" rel="noopener">https://julialang.org/downloads/</a><br>下就能看到：</p><p><img src="https://tony4ai-1251394096.cos.ap-hongkong.myqcloud.com/blog_images/Julia-Lang-1-Install/julia-web.png" alt="Jupiter-web"></p><p>可以看到我当前的版本是1.0，目前1.1在测试，所以你们使用的时候可能都2.x了，如果基本套路变了，那么你就要仔细看一下说明了。</p><h3 id="Mac下安装Julia"><a href="#Mac下安装Julia" class="headerlink" title="Mac下安装Julia"></a>Mac下安装Julia</h3><p>我们在表格中找到 Mac对应的安装包 .dmg 格式<br><img src="https://tony4ai-1251394096.cos.ap-hongkong.myqcloud.com/blog_images/Julia-Lang-1-Install/markdown-img-paste-20180929222929641.png" alt=""><br>然后点击下载（速度有点慢），<br><img src="https://tony4ai-1251394096.cos.ap-hongkong.myqcloud.com/blog_images/Julia-Lang-1-Install/markdown-img-paste-20180929223057287.png" alt=""><br>按照Mac程序的一般安装方法，拖到应用里面即可。<br><img src="https://tony4ai-1251394096.cos.ap-hongkong.myqcloud.com/blog_images/Julia-Lang-1-Install/markdown-img-paste-2018092922315751.png" alt=""><br>这个时候就算安装完了，但是使用mac的程序员启动这种没界面的应用喜欢使用命令行，这里的做法是，建立一个从应用到命令行搜索目录的软连接：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /Applications/Julia-1.0.app/Contents/Resources/julia/bin/julia /usr/<span class="built_in">local</span>/bin/julia</span><br></pre></td></tr></table></figure></p><p>当前julia版本是1.0。</p><font color="ff0000">注意这个”Julia-1.0.app” 会随版本不同，不要照抄这段命令。</font><p>在命令行中启动julia如果出现下图，恭喜，成功了：<br><img src="https://tony4ai-1251394096.cos.ap-hongkong.myqcloud.com/blog_images/Julia-Lang-1-Install/markdown-img-paste-20180929223755799.png" alt=""></p><h3 id="Windows下安装Julia"><a href="#Windows下安装Julia" class="headerlink" title="Windows下安装Julia"></a>Windows下安装Julia</h3><p>Windows下安装就要注意一下操作系统版本了：<br><img src="https://tony4ai-1251394096.cos.ap-hongkong.myqcloud.com/blog_images/Julia-Lang-1-Install/markdown-img-paste-20180929223855214.png" alt=""><br>windows7 和server 2012 需要特别的组件，原因我也不知道，我目前只有一台Windows 10 的pc，所以我就下载64-bit的安装包，安装结果没测试，大家有问题留言吧。<br>如果想在cmd中启动，需要添加环境变量，但是windows程序员一般不用cmd启动程序</p><h3 id="Linux下安装Julia"><a href="#Linux下安装Julia" class="headerlink" title="Linux下安装Julia"></a>Linux下安装Julia</h3><p>Linux下我目前只有ubuntu</p><h3 id="方式一：apt"><a href="#方式一：apt" class="headerlink" title="方式一：apt"></a>方式一：apt</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install julia</span><br></pre></td></tr></table></figure><p>输入sudo密码就可以完成安装了<br><img src="https://tony4ai-1251394096.cos.ap-hongkong.myqcloud.com/blog_images/Julia-Lang-1-Install/markdown-img-paste-20180929224835566.png" alt=""><br>但是问题是，我的ubuntu版本比较低，所以对应源上的Julia还是老版本的<br><img src="https://tony4ai-1251394096.cos.ap-hongkong.myqcloud.com/blog_images/Julia-Lang-1-Install/markdown-img-paste-20180929224930362.png" alt=""></p><p>看到了吧，官网的版本都到1.0.0 了，</p><h3 id="方式二：下载tar-jz"><a href="#方式二：下载tar-jz" class="headerlink" title="方式二：下载tar.jz"></a>方式二：下载tar.jz</h3><p>对应的办法就是卸掉这个然后去下载官网上的通用版本，然后解压编译：</p><p><img src="https://tony4ai-1251394096.cos.ap-hongkong.myqcloud.com/blog_images/Julia-Lang-1-Install/markdown-img-paste-20180929225148724.png" alt=""><br>注意你的平台，是X86 还是arm以及操作系统的位数。<br>如果你是linux程序员，我觉得后面的事我没有一步一步跟你说了，因为都是linux下通用的编译安装步骤，这里不再赘述了。</p><h2 id="安装Atom，搭建IDE"><a href="#安装Atom，搭建IDE" class="headerlink" title="安装Atom，搭建IDE"></a>安装Atom，搭建IDE</h2><p>接着我们要安装一款编辑器，github出品，良心之作 —— atom，这款编辑器的优点就是开源，速度快，核心小，尤其是对于从windows刚来linux，或者mac的同学们，离开vs有可能水土不服，但是相信我，如果你用了atom或其他类似的编辑器，你就会忘记那个好多G的vs。<br>下载atom: <a href="https://atom.io" target="_blank" rel="noopener">https://atom.io</a><br>有多重平台，Mac，Linux，Windows对应的安装包，安装套路和Julia类似，都是普通的安装过程，然后，最关键的一步<br>注意，这是我目前正在写文章的atom的状态：<br><img src="https://tony4ai-1251394096.cos.ap-hongkong.myqcloud.com/blog_images/Julia-Lang-1-Install/markdown-img-paste-20180929225947832.png" alt=""><br>比较正常，接着我们要安装juno了: <a href="http://junolab.org" target="_blank" rel="noopener">http://junolab.org</a> 注意区分juno，有好多叫juno的项目，比如NASA什么的。还有就juno要求的atom平台版本号。<br><img src="https://tony4ai-1251394096.cos.ap-hongkong.myqcloud.com/blog_images/Julia-Lang-1-Install/markdown-img-paste-20180929230139168.png" alt=""><br>Juno是一个atom上的插件，Windows 或者Linux 使用快捷键 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mac下使用```Cmd+,``` 打开atom的插件安装界面</span><br><span class="line">![](https://tony4ai-1251394096.cos.ap-hongkong.myqcloud.com/blog_images/Julia-Lang-1-Install/markdown-img-paste-20180929230510192.png)</span><br><span class="line">选择```install</span><br></pre></td></tr></table></figure></p><p><img src="https://tony4ai-1251394096.cos.ap-hongkong.myqcloud.com/blog_images/Julia-Lang-1-Install/markdown-img-paste-20180929230703482.png" alt=""><br>安装完juno后，他会自己给你安装一些他需要的扩展：<br><img src="https://tony4ai-1251394096.cos.ap-hongkong.myqcloud.com/blog_images/Julia-Lang-1-Install/markdown-img-paste-20180929231412150.png" alt=""></p><p>右上角安装完成后重启Atom就有Juno可以用了，就这样：<br><img src="https://tony4ai-1251394096.cos.ap-hongkong.myqcloud.com/blog_images/Julia-Lang-1-Install/markdown-img-paste-20180929232623129.png" alt=""></p><p>然后我们就成功了，当网速不那么流畅的时候稍微等一会儿，juno安装完成会提示你。不要着急。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天我们完成了Julia的环境搭建，有了环境，有了IDE，我们就能大展拳脚，看看Julia是不是真的那么高效便捷了。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li><a href="https://docs.julialang.org/en/v1/manual/getting-started/" target="_blank" rel="noopener">https://docs.julialang.org/en/v1/manual/getting-started/</a></li></ol><hr><p><a href="https://face2ai.com/Julia-Lang-1-Install" target="_blank" rel="noopener">原文地址: https://face2ai.com/Julia-Lang-1-Install</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; 本介绍Julia环境的搭建，包括在Mac，Linux以及在Windows下的安装过程，最后我们使用atom搭建一个Julia IDE&lt;br&gt;&lt;strong&gt;Keywords:&lt;/strong&gt; Julia环境搭建, Mac,Julia Windows,Julia Linux,Juno&lt;br&gt;
    
    </summary>
    
      <category term="Julia" scheme="http://www.face2ai.com/categories/Julia/"/>
    
      <category term="Freshman" scheme="http://www.face2ai.com/categories/Julia/Freshman/"/>
    
    
      <category term="Julia" scheme="http://www.face2ai.com/tags/Julia/"/>
    
      <category term="Julia环境搭建" scheme="http://www.face2ai.com/tags/Julia%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
      <category term="Julia Mac" scheme="http://www.face2ai.com/tags/Julia-Mac/"/>
    
      <category term="Julia Windows" scheme="http://www.face2ai.com/tags/Julia-Windows/"/>
    
      <category term="Julia Linux" scheme="http://www.face2ai.com/tags/Julia-Linux/"/>
    
      <category term="Juno" scheme="http://www.face2ai.com/tags/Juno/"/>
    
  </entry>
  
  <entry>
    <title>【强化学习】 1.5 强化学习的一个扩展举例</title>
    <link href="http://www.face2ai.com/RL-RSAB-1-5-An-Extended-Example/"/>
    <id>http://www.face2ai.com/RL-RSAB-1-5-An-Extended-Example/</id>
    <published>2018-09-28T00:42:24.000Z</published>
    <updated>2018-10-07T09:11:15.434Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Abstract:</strong> 本文介绍强化学习的一个具体例子，Tic-Tac-Toe，作为一种下棋类游戏，Tic-Tac-Toe规则简单，而且问题规模小，容易进行深入分析，了解强化学习在具体例子中的执行过程，进而了解强化学习的性质和特点。<br><strong>Keywords:</strong> 强化学习，强化学习举例，Tic-Tac-Toe<br><a id="more"></a></p><h1 id="强化学习的一个扩展举例"><a href="#强化学习的一个扩展举例" class="headerlink" title="强化学习的一个扩展举例"></a>强化学习的一个扩展举例</h1><p>今天我们来讲一个很有趣的例子，英文名字叫”Tic-Tac-Toe” 中文名字有翻译成“井字棋”或者什么的，我们这里为了方便就称之为“井字棋”，叫井字棋的原因是因为其棋盘是个“井”字形的，玩法简单，但是这个玩的过程可以使用强化学习的方法来学习，这个简单的棋可以让我们从各个细节审视强化学习的特点，有点，缺点，以及一些小技巧。</p><h2 id="“Tic-Tac-Toe”简介"><a href="#“Tic-Tac-Toe”简介" class="headerlink" title="“Tic-Tac-Toe”简介"></a>“Tic-Tac-Toe”简介</h2><h3 id="规则描述"><a href="#规则描述" class="headerlink" title="规则描述"></a>规则描述</h3><p>Tic-Tac-Toe的规则描述如下：</p><ol><li>使用 $3\times 3$ 的正方形棋盘，双方各使用 ‘x’和’o’ 作为棋子，轮流下棋，</li><li>谁的棋子最先连成一行或者一列，或者对角线，那么获胜，棋局结束</li><li>对方完成这个过程，则失败</li><li>如果在最终双方都没能连成一行或者一列，或者对角线的情况下，棋局结束，则为平局。</li></ol><p>下图来自Wikipedia:<a href="https://zh.wikipedia.org/wiki/井字棋" target="_blank" rel="noopener">“井字棋”</a></p><p><img src="https://tony4ai-1251394096.cos.ap-hongkong.myqcloud.com/blog_images/RL-RSAB-1-5-An-Extended-Example/Tictactoe1.gif" alt=""></p><p>上面的棋局，使用 ‘x’ 的一方率先完成连成一行的准则，故执’x’一方获胜。</p><h3 id="简单规则下的问题"><a href="#简单规则下的问题" class="headerlink" title="简单规则下的问题"></a>简单规则下的问题</h3><p>下面这个视频是我在Google上找到的一个小程序录的一段视频。</p><video src="https://tony4ai-1251394096.cos.ap-hongkong.myqcloud.com/blog_images/RL-RSAB-1-5-An-Extended-Example/ttt.mov" controls="controls" style="max-width: 100%; display: block; margin-left: auto; margin-right: auto;"><br>your browser does not support the video tag<br></video><p>可见，在高级的情况下，双方（我和AI）基本都没法获胜，也就是平局会大量出现，原因是，我们对这种棋的技巧掌握的都很熟练，无法在现行环境（规则）下战胜对方，通过这个观察我们也能发现，在规则相对简单的游戏（“博弈”）中，平局会大量出现。<br>那么问题就要来了，我们 - 也就是人，在这种简单的规则下，多以平局收场，那么这怎么训练agent呢？如果每局训练总是平局，agent就不知道往什么方向走了。这里我们就要做出一些修改，我们让与我们agent下棋的人或者另一个agent不那么高级，换句话说，我们在简单规则下，降低规则执行者的能力，进而模拟出更高级的博弈（所谓更高级的博弈，无非是我们能力不足才会觉得当前环境，或者规则很困难）。<br>在后面的训练里，agent会将平局和失败都当做失败来处理，agent的目标明确，就是胜利。</p><h3 id="非强化学习型的解决方法"><a href="#非强化学习型的解决方法" class="headerlink" title="非强化学习型的解决方法"></a>非强化学习型的解决方法</h3><p>这个棋局太简单，但是在如此简单的规则下，传统方法（非学习方法）都有诸多问题：</p><ol><li>使用传统的“极大极小化”（minimax）方法，这个方法会假定对方按照某个既定方案下棋，而事实是对方可能无既定方案，或者既定方案我们永远无法得知。所以这个传统的博弈思想在此不适用。而且“极大极小化”（minimax）方法有个非常大的缺点：如果其认定当前状态必然失败的情况下，即使后面对手出现重大失误（可以逆转取胜的机会），其也不会采取任何致胜招数，而是按照既定失败的套路继续下去。</li><li>对于这种连续决策型问题的传统的优化方法，例如动态规划(dynamic programming)，可以计算出在对阵任何对手时候的最优解，但是前提是：对手的全部信息要作为输入提前提交给算法，其中包括在某特定情况（棋局）下，对手下一步棋下在哪的概率。如果我们提前不知道这些信息（大部分情况下，这个信息无法获得）</li><li>对于2中的动态规划方法，有另一种改进版就是在训练时和对手多次交手，从而记录学习出对手的信息，或者叫做给对手建模（model）然后再使用动态规划来寻找答案。</li></ol><p>上面3中方法中，1和2对解决问题基本没有帮助，3有帮助。3和我们后面会介绍的很多强化学习方法有着非常相似的思路。</p><h2 id="进化方法-Evolutionary-Method-学习-“Tic-Tac-Toe”"><a href="#进化方法-Evolutionary-Method-学习-“Tic-Tac-Toe”" class="headerlink" title="进化方法(Evolutionary Method)学习 “Tic-Tac-Toe”"></a>进化方法(Evolutionary Method)学习 “Tic-Tac-Toe”</h2><p><a href="https://face2ai.com/RL-RSAB-1-4-0-Limitations-and-Scope/" target="_blank" rel="noopener">进化方法</a> 中讲解了进化方法的缺点，就是没有使用agent和环境之间的交互信息来改变agent。而这里如果把进化方法直接使用到“井字棋”中，其表策略（policy）的特点是：直接search全部可能的位置，找到获胜概率最大的位置，然后下棋。也就是，策略要考虑到当前盘面（ $3\times 3$ 的棋盘上 x和o的分布）并给出获胜概率最大的下棋位置。而这个概率的获得就需要和对手多次下棋，记录，学习出来的。有了这些信息，agent就知道接下来一步或者接下来很多步应该怎么走。<br>一个典型的进化方法就是在“策略空间”的 hill-climb ，这种方法的策略是逐渐找出能提高表现的策略（并不是一下找到最优的方法，而是像爬山一样，每一步都找到一个能提高agent表现的方案，一步一步的向上爬）。<br>遗传方法就更加直接暴力了，直接直接评估大量的策略(policies)，去除不合格的，留下好的，然后产生新一代的，以此迭代，直到问题解决。<br>解决“井字棋”问题，理论上存在很多种不同的优化方法。</p><h2 id="评价函数-Value-Function-学习-“Tic-Tac-Toe”"><a href="#评价函数-Value-Function-学习-“Tic-Tac-Toe”" class="headerlink" title="评价函数(Value Function)学习 “Tic-Tac-Toe”"></a>评价函数(Value Function)学习 “Tic-Tac-Toe”</h2><p>上面我们说了进化方法在井字棋中使用，下面我们就要看看另一个方向的方法 —— 评价函数(value Function)的方法了。</p><h3 id="设计评价函数"><a href="#设计评价函数" class="headerlink" title="设计评价函数"></a>设计评价函数</h3><p>我们列一个表，这个表中的每个格子对应一种状态（state），整张表就对应井字棋的全部情况，这个表的每一项都对应一个概率值，这个概率值表示当前状态下最后获胜的期望，注意两点，一个是当前的状态，第二是最终获胜的期望。这个期望，我们就把其当做评价函数的结果，value —— value值。这个表就是我们的评价函数(Value Function)了.<br>在井字棋中，这个表就包含下一步棋应该怎么走的评估。通过当前状态，我们可以缩小下一步可能出现的状态范围，然后比较所有可能的状态，如果A状态比B状态有更高的获胜期望，那么我们认为A状态比B状态好，所以我们倾向于把棋子走到A状态显示的位置。<br>对于这个状态表，假设我们执x，那么如果某状态中包含x在一行或者一列或者对角线，那么这个状态的获胜期望是1，相反，如果o在一行或者一列或者对角线，那么这个状态的获胜期望是0；同样，如果对应状态是棋盘下满，而没有获胜方，这时候期望同样是0 。除了上述这些情况，其他状态的<strong>初始化</strong>值都是0.5，即有一半的可能性会获胜。</p><h3 id="执行-exploitation-和探索-exploration"><a href="#执行-exploitation-和探索-exploration" class="headerlink" title="执行(exploitation)和探索(exploration)"></a>执行(exploitation)和探索(exploration)</h3><p>当我们有了这张表（上面的评价函数）我们就有了制胜法宝，但是具体执行也是有不同方案的，我们可以查找最大value的状态，然后执行贪心(greedily)选择，这是使得获胜期望最大的策略，也就是完全执行表（value function）中的指示，这个被称为exploitation。<br>但是我们有时候（偶尔，occasionally）在某些步骤中不选择最大value的状态，而是选择随机状态，因为这种方式可能带我们到一个前所未见的state下。</p><p>上面两段描述的评价函数，以及状态表在井字棋中可以表现为下图：</p><p><img src="https://tony4ai-1251394096.cos.ap-hongkong.myqcloud.com/blog_images/RL-RSAB-1-5-An-Extended-Example/table.png" alt="table"></p><h3 id="学习评价函数（value-function）"><a href="#学习评价函数（value-function）" class="headerlink" title="学习评价函数（value function）"></a>学习评价函数（value function）</h3><p>在下棋的过程中，我们不断修改已有value function对于井字棋，也就是上面我们提到的那张表，我们的目标是试图使其更加准确，为了达到这个目的，我们增加了一步“返回”（back up） 过程（上图中的红色箭头），这个过程在每一步贪心选择后执行，这一步执行的实质是通过当前状态值（value）来适当修改上一步状态的value，使它更接近现在状态的值（评价函数的结果，value），比如图中的红箭头就是让e的值（评价函数的结果，value）更接近g的值（评价函数的结果，value）。<br>上面的数学表达为，让 $s$ 为贪心选择之前的状态的值（评价函数的结果，value）， $s’$ 为贪心选择后的值（评价函数的结果，value），然后我们的back up更新 $s$ 值，方式是：<br>$$<br>V(s)\leftarrow V(s)+\alpha[V(s’)-V(s)]<br>$$</p><p>其中 $\alpha$ 是一个小的正小数，叫做“步长”（step-size）参数，这个参数影响学习速率（the rate of learning）注意这里rate是速率的意思，而不是比率的意思，所以学习率这种翻译，我觉得欠妥。<br>这种基于 $[V(s’)-V(s)]$ 的变化方式（update rule）被称为“时序差分学习”（temporal-difference learning），字面解释：基于两个不同时间点的值（评价函数的结果，value）的差值的方法，这个解释基本能反应这类方法的特点。<br>这类方法是我们后面要重点学习。</p><p>上述方法对于这个任务可以非常出色的得出不错的结果，例如，<strong>在步长参数（step-size）被精确递减后</strong>，这个算法对于固定的对手是收敛的，每一步都能给出胜算最高的走法。也就是说，这个方法对于一个固定的对手给出了最优策略。这里的一个关键就是 <strong>步长参数（step-size）</strong> 的调整，如果这个参数不调整，那么最后的结果也会收敛，但是速度会慢很多。</p><h2 id="“进化方法”与“评价函数”的区别"><a href="#“进化方法”与“评价函数”的区别" class="headerlink" title="“进化方法”与“评价函数”的区别"></a>“进化方法”与“评价函数”的区别</h2><p>上面这些细节也佐证了我们前面提到的：“进化方法”和“评价函数学习法”的区别：</p><ol><li>进化方法的为了学习一个策略，其根本原则是策略不变（不是永久不变，是在目前的短时间内），而去和对手进行多场游戏（就是和环境的交互，interaction），或者使用一个对手的模型，来模拟进行多场游戏。在进行多次游戏后，胜利的次数给出当前策略胜率的无偏估计，然后这个无偏估计被用来优化策略（根据一定的规则从多个策略中淘汰某些，或者其他办法生成新的策略）。<br>但是问题是每次策略进化都需要多场游戏来计算概率，而每场游戏内的信息被忽略掉了（因为计算概率只关心结果的 —— 胜利出现的次数）而且当一个player（也可以成为agent）获得了胜利，他本场比赛的所有行为都会被认为是正确的，且每一步给予相同的得分，但实际上并不是这样，首先并不是每一步的重要性都一样，其次是并不是每一步都是正确的选择。</li><li>对比之下“评价函数学习法”就有不同的表现了，每一步棋和环境的交互信息都会被利用来学习。</li></ol><p>总之，进化方法和“评价函数学习法”都是在搜索policy的空间，但是“评价函数学习法”搜索起来更高效，因为他利用了更多的有效信息。</p><h2 id="“Tic-Tac-Toe”-中的强化学习"><a href="#“Tic-Tac-Toe”-中的强化学习" class="headerlink" title="“Tic-Tac-Toe” 中的强化学习"></a>“Tic-Tac-Toe” 中的强化学习</h2><p>这个小小的游戏基本展现了强化学习的所有特性：</p><ol><li>首先强调和环境的交互，这里就是和对手下棋。</li><li>目标明确，正确的行为需要 <em>Planning</em> 或者 <em>Foresight</em> 来处理延迟出现的结果</li><li>另一个显著的特征是，RL形成有效的 <em>Planing</em> 以及 <em>lookahead</em> ，而且这个过程不需要使用对手模型（model of opponent），也不会对后面全部的可选操作序列进行搜索（减少policy的搜索空间）</li></ol><p>虽然RL的这几个有点很是吸引人，但是这不能掩盖其某些缺点：</p><ol><li>训练的时的对手，不可能是人，而还是程序，所以这个对手不是Nature的</li><li>学习过程也是打碎成不同的步骤（对于井字棋每一局都是一步），而不是连续的进行，只有下完了才会产生reward信号，而不是连续的。</li><li>同样对于某些连续的任务，我们也要把它拆成离散形式。</li></ol><p>井字棋的搜索范围很小，现在alpha go所面对搜索空间比井字棋大到不知道哪去了~，1992年的时候就有学者研究了比井字棋更复杂的游戏，空间大概规模是 $10^{20}$ 他们使用了神经网络作为模型，结合上面的方法得出了很好的结果，具体我们在后面16章学习。<br>强化学习面对如此巨大的policy空间的行为，主要取决于他对之前学习的信息的理解程度，理解的越好，其行为就更加可靠，反之则不可靠。</p><h2 id="先验知识-Prior-Knowledge-与模型-Model"><a href="#先验知识-Prior-Knowledge-与模型-Model" class="headerlink" title="先验知识(Prior Knowledge)与模型(Model)"></a>先验知识(Prior Knowledge)与模型(Model)</h2><p>在井字棋游戏中，RL的agent只知道游戏规则毫无游戏经验或者先验知识，先验知识是锦上添花的元素，也就是，有或者没有这个要靠缘分，就算没有我们也要解决问题，而如果有，那么我们可以利用先验知识节省大量时间，或者大幅度提高结果。RL处理先验知识有多种方式，并且对学习结果。<br>我们目前处理的情况都是当前环境对agent有明确的反馈，且state明确，在有些问题中state可能是隐藏的或者有大量重复的state这种情况过于复杂，不在我们初级范围内。<br>Model同样是强化学习中的一个组成要素：当我们的RL（agent）学习应该怎么样应对不同的状况的时候，他需要思考的就是环境会怎么对他的action进行反应，有些问题确实如此，环境对action的反应就是一个模型，但是有的问题可能比这要更复杂一些，他们有的时候什么模型都没有，不知道环境会做出什么样的反应，面对这样的问题RL也有解决方案。同样的，有模型可以帮助RL更快的学习。<br>但是我们的井字棋就没有这个model，原因是对手怎么下棋是不可能有模型的，这就是个 Model-Free system。存在精确模型的系统由于模型被精确的使用，所以做起来相对简单，但是有的时候建立模型的过程会成为这个问题的瓶颈，本书中我们会讨论一些Model-Free的问题，同时组合这些问题成为更复杂的系统。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文通过研究Tic-Tac-Toe这个小游戏，从实际应用的角度分析了RL的各个方面，基本涵盖了大部分主要内容，后面我们进入第二章，开始分析具体算法，欢迎大家关注。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>Sutton R S, Barto A G. Reinforcement learning: An introduction[J]. 2011.</p><hr><p>原文地址:<a href="https://face2ai.com/RL-RSAB-1-5-An-Extended-Example" target="_blank" rel="noopener">https://face2ai.com/RL-RSAB-1-5-An-Extended-Example</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; 本文介绍强化学习的一个具体例子，Tic-Tac-Toe，作为一种下棋类游戏，Tic-Tac-Toe规则简单，而且问题规模小，容易进行深入分析，了解强化学习在具体例子中的执行过程，进而了解强化学习的性质和特点。&lt;br&gt;&lt;strong&gt;Keywords:&lt;/strong&gt; 强化学习，强化学习举例，Tic-Tac-Toe&lt;br&gt;
    
    </summary>
    
      <category term="Reinforcement Learning" scheme="http://www.face2ai.com/categories/Reinforcement-Learning/"/>
    
      <category term="RL-An Introduction" scheme="http://www.face2ai.com/categories/Reinforcement-Learning/RL-An-Introduction/"/>
    
    
      <category term="强化学习" scheme="http://www.face2ai.com/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>【强化学习】 1.4.1 强化学习与优化方法</title>
    <link href="http://www.face2ai.com/RL-RSAB-1-4-1-Connection-to-Optimization-Method/"/>
    <id>http://www.face2ai.com/RL-RSAB-1-4-1-Connection-to-Optimization-Method/</id>
    <published>2018-09-26T00:50:41.000Z</published>
    <updated>2018-10-07T09:11:02.091Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Abstract:</strong>本文介绍强化学习和优化方法之间的关系，他们之间一些共同误区以及强化学习的工程性质<br><strong>Keywords:</strong>强化学习，优化方法，强化学习工程化</p><a id="more"></a><h1 id="强化学习与优化方法"><a href="#强化学习与优化方法" class="headerlink" title="强化学习与优化方法"></a>强化学习与优化方法</h1><p>优化方法是机器学习的一个关键组成部分，大部分监督学习和部分非监督学习都要依靠优化方法找到模型的参数，强化学习中也会使用优化方法中的一些算法来使agent获得更多的reward signal，而强化学习或者优化方法在进行过程中有些说法会让人感到迷惑。</p><h2 id="“强化学习的目标”与“优化问题的目标”"><a href="#“强化学习的目标”与“优化问题的目标”" class="headerlink" title="“强化学习的目标”与“优化问题的目标”"></a>“强化学习的目标”与“优化问题的目标”</h2><p>前面我们提到过，强化学习的目标或者叫做战略目标就是让agent获得更多的reward signal，注意“更多”这个说法，从数学的角度讲，更多是个增长的过程，而这个过程有没有极限，也就是会不会有“最多”这种情况，这也成了强化学习的一个极限。</p><p>同样的问题也出现在优化问题中，优化问题的解是否还可以进一步优化，或者，这个解已经是全局最优的了，这个判断其实是非常困难的。</p><p>所以，我们在描述强化学习或者优化问题的时候，提到“最大化xx的鼓励信号(reward signal)….”或者 “最优化xx函数” 这些都不是强调一定要找到最大的唯一解，事实上，这个解可能本身就不存在，或者即使存在，由于种种原因，我们也没办法找到这个解。<br>强化学习要做的就是不断的让agent去尝试找到比目前更好的 <strong>策略(policies)</strong> 来得到更多的鼓励信号(reward signal)<br>如果用一句话概括就是：</p><blockquote><p>“Optimization is not the same as optimality”（优化不等于最优）</p></blockquote><p>如果某个优化方法在别的系统中表现非常优秀，但是当他移植到其他系统中仍然需要仔细评估，和测试，因为系统的 “不可预测性” 使得算法的工作 “环境非常复杂”，所以不能依靠算法之前在别的系统的表现来随意的评估其在当前系统中的表现。agent通常能够发现预料之外的 <strong>策略(policies)</strong> 来获得意想不到的好结果。如果把这个过程对比自然界中的生物的行为的话，那么就应该是我们所说的“创造力”了。这种创造力表现在，“ <strong>变化（variation）</strong> ”和“ <strong>选择(selection)</strong> ”上，这是进化能解决物种所面对的生存挑战的基础，也是强化学习解决人工智能所面对的挑战的基础。但是创造是有风险的，因为有的时候我们并不知道“变化（variation）”是朝向好的方向还是不好的方向或者根本就是无意识无目标的变化。</p><p>优化，变化等以上观点一直以来都被思考，就是哪个才是最好的，如果改变agent目前的策略效果会变好还是变坏是不确定的，所谓的继续优化是 “优化” 还是 “恶化”？一个很有意思的比喻是；</p><blockquote><p>“Be careful what you wish for because you just might get it”(小心你想得到的，有可能你已经得到了)</p></blockquote><h2 id="强化学习和工程"><a href="#强化学习和工程" class="headerlink" title="强化学习和工程"></a>强化学习和工程</h2><p>为了解决上面这个“世纪难题”（最优性，不可预测性，变化，等问题），有很多策略（注意这是抽象的宏观的方案，而不是具体实施的方案）被使用，比如：</p><ul><li>限制agent的可变化方向</li><li>使目标函数(objective function)对风险敏感</li></ul><p>但是这些方案都是比较片面的解决方法，不能从根本解决问题，标准工程化的要求是，在系统正式上线工作之前，要经过严格的测试，因为系统一旦上线，产品一旦销售，我们的技术必须对使用者负责，如果系统存在不可预测的风险，且风险对于使用者是高危的，不可抗拒的，那么我们必须在测试阶段发现，并且解决，这和其他工程师一样的。由于强化学习等机器学习算法都存在不可预知的行为，所以在上线之前更应该严格评估。</p><p>优化结果的随机性不可预测性只是强化学习工程化中的风险点之一，其他工程中存在风险，在强化学习中同样也大大小小的存在，所以在评估时，不能只关注强化学习的风险点，比如数据安全，网络安全，等等在其他工程中的风险，在强化学习都一并存在。<br>讨论详细的问题在我们这里很不现实，我们只要记住，严格的测试系统，强化学习系统，机器学习系统，提前发现风险，解决风险，降低风险这些事情无论何时都是重中之重。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了强化学习和优化方法之间的一些概念混乱，优化不一定找到最优解。以及强化学习的工程化问题，降低风险，解决风险是所有机器学习工程应用中的重点。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>Sutton R S, Barto A G. Reinforcement learning: An introduction[J]. 2011.</p><p>原文地址：<a href="https://face2ai.com/RL-RSAB-1-4-1-Connection-to-Optimization-Method" target="_blank" rel="noopener">https://face2ai.com/RL-RSAB-1-4-1-Connection-to-Optimization-Method</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt;本文介绍强化学习和优化方法之间的关系，他们之间一些共同误区以及强化学习的工程性质&lt;br&gt;&lt;strong&gt;Keywords:&lt;/strong&gt;强化学习，优化方法，强化学习工程化&lt;/p&gt;
    
    </summary>
    
      <category term="Reinforcement Learning" scheme="http://www.face2ai.com/categories/Reinforcement-Learning/"/>
    
      <category term="RL-An Introduction" scheme="http://www.face2ai.com/categories/Reinforcement-Learning/RL-An-Introduction/"/>
    
    
      <category term="强化学习" scheme="http://www.face2ai.com/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="优化方法" scheme="http://www.face2ai.com/tags/%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【Julia】Julia编程语言介绍</title>
    <link href="http://www.face2ai.com/Julia-Lang-0-Introduction/"/>
    <id>http://www.face2ai.com/Julia-Lang-0-Introduction/</id>
    <published>2018-09-25T04:04:01.000Z</published>
    <updated>2018-10-04T14:59:39.584Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Abstract:本文是介绍Julia编程语言系列博客的第一篇，本系列用短小的博客介绍Julia编程的基础知识</strong><br><strong>Keywords:Julia编程语言,Julia简介,Julia特点</strong></p><a id="more"></a><h1 id="Julia-编程语言"><a href="#Julia-编程语言" class="headerlink" title="Julia 编程语言"></a>Julia 编程语言</h1><h2 id="Julia-简介"><a href="#Julia-简介" class="headerlink" title="Julia 简介"></a>Julia 简介</h2><p>Julia语言是MIT的几个科学家，觉得Matlab还有Python不太适合自己的行业，所以自己搞出来的一种编程语言，和另外几百中编程语言一样，其有独特的受众，那就是 —— 数据科学。Julia是小众的，其诞生以来的基本目标就是，能像C语言编写的程序一样快，但是又要有Ruby一样的动态性。Julia主要的目标用户是数据科学家，统计学习，机器学习从业者等。</p><h3 id="Julia-与-Python"><a href="#Julia-与-Python" class="headerlink" title="Julia 与 Python"></a>Julia 与 Python</h3><p>平时的工作，基本都是跟TB，PB级别的数据打交道，所以，Python速度从一开始就受到诟病，虽然你可以让python结合c语言来提速，但是对于特异性很高，没有现有库支持的任务，那种工作量和直接写c语言差不多。<br>而且，Julia程序及其好写，我个人觉得Python的面向对象的机制对于数据科学家来说，基本没什么用，我们更多的是按照某个流程处理全部数据，而不需要用到类；<br>由于Python通用性，对于数据科学家来说，干点什么事都需要import一大堆各种各样的包，读个csv都要先import点什么。但是Julia针对数据处理，所以很多包都内置了，相对于Python会简洁很多。<br>Python用途更广泛，而Julia面向数据处理，所以这些差异都在情理之中。</p><h3 id="Julia-与-c"><a href="#Julia-与-c" class="headerlink" title="Julia 与 c++"></a>Julia 与 c++</h3><p>当然C++的特性基本更用不到了，如果使用C++没有用到多态和继承，那么就相当于在写c语言，而数据科学，想来想去，也不太会用到多态和继承。</p><h3 id="Julia-与-R"><a href="#Julia-与-R" class="headerlink" title="Julia 与 R"></a>Julia 与 R</h3><p>至于R语言，个人不太了解，但是Julia肯定比他快。<br>Julia可以在使用过程中轻松的集成R或者Python等语言编写的库，这个可以大大的提高工作效率。</p><h2 id="Julia-有什么特点"><a href="#Julia-有什么特点" class="headerlink" title="Julia 有什么特点"></a>Julia 有什么特点</h2><p>Julia的特点很多，但是主要概括如下，如果你的工作需要这些特点，那么Julia是你的好选择。</p><ol><li>卓越的性能<ul><li>某些任务速度堪比C语言</li></ul></li><li>强大的基础库<ul><li>内置线性代数运算，高效</li></ul></li><li>支持分派<ul><li>同一个函数可以实现不同的过程(比c++的多态更简单)</li></ul></li><li>容易上手<ul><li>Julia语言非常简单，学过c语言的同学可以在24小时内上手</li></ul></li><li>用户友好的界面<ul><li>本地还是远程的Julia用户界面都很好用</li></ul></li><li>与其他语言对接<ul><li>无缝拼接，R，Python和C</li></ul></li><li>开源<ul><li>所有文档都可以找到</li></ul></li><li>开发者承诺<ul><li>不会开发到半路然后跑路</li></ul></li><li>自定义函数的性能<ul><li>自己写的函数也很快，不会只有内置的函数快，而自定义的速度慢</li></ul></li><li>并行<ul><li>轻松的并行，数据科学最需要的就是并行，而Python真的不太好用</li></ul></li><li>灵活性<ul><li>开发程序灵活，可以找到各种问题的方案解决</li></ul></li></ol><h2 id="为什么选择Julia"><a href="#为什么选择Julia" class="headerlink" title="为什么选择Julia"></a>为什么选择Julia</h2><p>如果你是跟数据打交道的，从事机器学习，数据处理类的工作，那么Julia的高效，并行，绝对是你的不二之选。<br>活跃的社区和丰富的功能，持续的更新，也是这门年轻的语言将会成功的先兆。<br>最主要的，就是效率，减少一分钟的运行时间，对于有些项目，可能是至关重要的，对于处理数据，我们需要提高的就是：效率，效率，还是效率</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了Julia的基本性质，如果Julia适合你，那么快加入吧。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol><li>Voulgaris Z. Julia for Data Science[M]. Technics Publications, 2016.</li><li><a href="https://en.wikipedia.org/wiki/Julia_(programming_language" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Julia_(programming_language)</a>)</li><li><a href="https://julialang.org" target="_blank" rel="noopener">https://julialang.org</a></li></ol><p><a href="https://face2ai.com/Julia-Lang-0-Introduction" target="_blank" rel="noopener">完整文章访问原文地址:https://face2ai.com/Julia-Lang-0-Introduction</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Abstract:本文是介绍Julia编程语言系列博客的第一篇，本系列用短小的博客介绍Julia编程的基础知识&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;Keywords:Julia编程语言,Julia简介,Julia特点&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Julia" scheme="http://www.face2ai.com/categories/Julia/"/>
    
      <category term="Freshman" scheme="http://www.face2ai.com/categories/Julia/Freshman/"/>
    
    
      <category term="Julia" scheme="http://www.face2ai.com/tags/Julia/"/>
    
      <category term="Julia编程语言" scheme="http://www.face2ai.com/tags/Julia%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Julia简介" scheme="http://www.face2ai.com/tags/Julia%E7%AE%80%E4%BB%8B/"/>
    
      <category term="Julia特点" scheme="http://www.face2ai.com/tags/Julia%E7%89%B9%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>【信息论、推理与学习算法】本系列博客介绍</title>
    <link href="http://www.face2ai.com/ITILA-Introduction-to-This-Series/"/>
    <id>http://www.face2ai.com/ITILA-Introduction-to-This-Series/</id>
    <published>2018-09-21T03:53:59.000Z</published>
    <updated>2018-10-04T14:31:13.889Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Abstract:</strong> 本文是本系列的第一篇，介绍本系列的主要内容<br><strong>Keywords:</strong> Information Theory，信息论，Inference，推理，Learning Algorithms，学习算法</p><a id="more"></a><h1 id="信息论、推理与学习算法介绍"><a href="#信息论、推理与学习算法介绍" class="headerlink" title="信息论、推理与学习算法介绍"></a>信息论、推理与学习算法介绍</h1><p>这个系列是信息论相关内容的介绍，信息论是什么可能有些做机器学习或者AI的同学们不太了解，而做通信的同学应该是非常清楚的，如何准确的定义信息论是什么，不在我的能力范围内，但是我们平时接触到的图像，或者简单点说灰度图像，一个8bit的像素点能有多少阶灰度，为什么有256，而不是258或者其他的，这个其实就属于信息论的知识范围，而信息论和机器学习有关系么？答案是肯定的，凡是处理信息，传递信息的过程，都多多少少跟信息论有那么点关系。<br>本系列主要面对的读者是： <strong>从事机器学习，人工智能类内容研究的同学，工程师，或者爱好者</strong><br>需要的背景知识：工程专业，科学类专业，或者数学类本科1，2年级的数学知识，包括，微积分，概率论，线性代数的基本知识（本站已经完成这些基础知识的全部博客，可以随时查阅）。<br>本书封面：<br><img src="https://tony4ai-1251394096.cos.ap-hongkong.myqcloud.com/blog_images/ITILA-Introduction-to-This-Series/cover.jpg" alt=""></p><h2 id="机器学习，信息论"><a href="#机器学习，信息论" class="headerlink" title="机器学习，信息论"></a>机器学习，信息论</h2><p>传统的信息论课程不仅包括Shannon的信息化思想，也有实际解决问题的现实应用，我们这个系列更加进一步的包括了：</p><ul><li>Bayesian Data Modelling</li><li>Monte Carlo Methods</li><li>Variational Methods</li><li>Clustering ALgorithms</li><li>Neural Networks</li></ul><p>为什么要把信息论和机器学习弄到一起？<br>信息论和机器学习是一个硬币的两面！<br>60年代一个领域 —— 控制理论（cybernetics）在信息论，计算机科学，和神经科学等学科中非常火爆，这些科学家们都在研究一个相同的问题，那时候信息论和机器学习还是属于同一类。大脑是一个压缩信息，进行沟通的系统，而在数据压缩（data conpression）和纠错码上（error-correcting code）表现最好的（state-of-the-art）的算法上使用的工具，在机器学习中也会使用。<br>这些种种迹象都表明，机器学习和信息论有着密切的关联，而我们本系列更关注的就是信息论在机器学习方面的应用，或者帮助我们理解一些算法的特点和局限。</p><h2 id="学习地图"><a href="#学习地图" class="headerlink" title="学习地图"></a>学习地图</h2><p>本书的目录如下,当然这些课不是我们所有要学的，我画了个地图，大概应该是按照这个地图来完成我们的博客的：</p><h3 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h3><p>1 Introduction to Information Theory<br>2 Probability, Entropy, and Inference<br>3 More about Inference</p><h3 id="I-Data-Compression"><a href="#I-Data-Compression" class="headerlink" title="I Data Compression"></a>I Data Compression</h3><p>4 The Source Coding Theorem<br>5 Symbol Codes<br>6 Stream Codes<br>7 Codes for Integers</p><h3 id="II-Noisy-Channel-Coding"><a href="#II-Noisy-Channel-Coding" class="headerlink" title="II Noisy-Channel Coding"></a>II Noisy-Channel Coding</h3><p>8 Dependent Random Variables<br>9 Communication over a Noisy Channel<br>10 The Noisy-Channel Coding Theorem<br>11 Error-Correcting Codes and Real Channels</p><h3 id="III-Further-Topics-in-Information-Theory"><a href="#III-Further-Topics-in-Information-Theory" class="headerlink" title="III Further Topics in Information Theory"></a>III Further Topics in Information Theory</h3><p>12 Hash Codes: Codes for Ecient Information Retrieval<br>13 Binary Codes<br>14 Very Good Linear Codes Exist<br>15 Further Exercises on Information Theory<br>16 Message Passing<br>17 Communication over Constrained Noiseless Channels<br>18 Crosswords and Codebreaking<br>19 Why have Sex? Information Acquisition and Evolution</p><h3 id="IV-Probabilities-and-Inference"><a href="#IV-Probabilities-and-Inference" class="headerlink" title="IV Probabilities and Inference"></a>IV Probabilities and Inference</h3><p>20 An Example Inference Task: Clustering<br>21 Exact Inference by Complete Enumeration<br>22 Maximum Likelihood and Clustering<br>23 Useful Probability Distributions<br>24 Exact Marginalization<br>25 Exact Marginalization in Trellises<br>26 Exact Marginalization in Graphs<br>27 Laplace’s Method<br>28 Model Comparison and Occam’s Razor<br>29 Monte Carlo Methods<br>30 Ecient Monte Carlo Methods<br>31 Ising Models<br>32 Exact Monte Carlo Sampling<br>33 Variational Methods<br>34 Independent Component Analysis and Latent Variable Modelling<br>35 Random Inference Topics<br>36 Decision Theory<br>37 Bayesian Inference and Sampling Theory</p><h3 id="V-Neural-networks"><a href="#V-Neural-networks" class="headerlink" title="V Neural networks"></a>V Neural networks</h3><p>38 Introduction to Neural Networks<br>39 The Single Neuron as a Classier<br>40 Capacity of a Single Neuron<br>41 Learning as Inference<br>42 Hopeld Networks<br>43 Boltzmann Machines<br>44 Supervised Learning in Multilayer Networks<br>45 Gaussian Processes<br>46 Deconvolution</p><h3 id="VI-Sparse-Graph-Codes"><a href="#VI-Sparse-Graph-Codes" class="headerlink" title="VI Sparse Graph Codes"></a>VI Sparse Graph Codes</h3><p>47 Low-Density Parity-Check Codes<br>48 Convolutional Codes and Turbo Codes<br>49 Repeat{Accumulate Codes<br>50 Digital Fountain Codes</p><h3 id="地图"><a href="#地图" class="headerlink" title="地图"></a>地图</h3><p>根据我们的目标和书上给出的建议，我们要学习下面这些章节，箭头之间表示先后关系，箭头指向的课程需要在前面的课程完成后才能进行：<br><img src="https://raw.githubusercontent.com/Tony-Tan/MachineLearningMath/master/information.png" alt=""></p><p>github: <a href="https://github.com/Tony-Tan/MachineLearningMath" target="_blank" rel="noopener">https://github.com/Tony-Tan/MachineLearningMath</a> 上有高清大图</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文是信息论的第一课，后续就围绕上图展开，对于基础不是了解的同学可以去看前面的其他博客，谢谢支持。</p><p>原文地址1：<a href="https://www.face2ai.com/ITILA-Introduction-to-This-Series">https://www.face2ai.com/ITILA-Introduction-to-This-Series</a>转载请标明出处</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; 本文是本系列的第一篇，介绍本系列的主要内容&lt;br&gt;&lt;strong&gt;Keywords:&lt;/strong&gt; Information Theory，信息论，Inference，推理，Learning Algorithms，学习算法&lt;/p&gt;
    
    </summary>
    
      <category term="Information Theory" scheme="http://www.face2ai.com/categories/Information-Theory/"/>
    
    
      <category term="算法" scheme="http://www.face2ai.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Information Theory" scheme="http://www.face2ai.com/tags/Information-Theory/"/>
    
      <category term="信息论" scheme="http://www.face2ai.com/tags/%E4%BF%A1%E6%81%AF%E8%AE%BA/"/>
    
      <category term="Inference" scheme="http://www.face2ai.com/tags/Inference/"/>
    
      <category term="推理" scheme="http://www.face2ai.com/tags/%E6%8E%A8%E7%90%86/"/>
    
      <category term="Learning Algorithms" scheme="http://www.face2ai.com/tags/Learning-Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>【强化学习】 1.4.0 “进化方法”和 “决策梯度方法”  概论</title>
    <link href="http://www.face2ai.com/RL-RSAB-1-4-0-Limitations-and-Scope/"/>
    <id>http://www.face2ai.com/RL-RSAB-1-4-0-Limitations-and-Scope/</id>
    <published>2018-09-20T04:59:01.000Z</published>
    <updated>2018-10-07T09:10:33.546Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Abstract:</strong>  本文介绍强化学习中的一些局限（limitation）和机遇（scope），介绍进化方法和决策梯度方法的区别和优劣<br><strong>Keywords:</strong> Evolutionary Method，进化方法，Policy Gradient Methods，决策梯度方法</p><a id="more"></a><h1 id="“进化方法”-和-“决策梯度方法”-概论"><a href="#“进化方法”-和-“决策梯度方法”-概论" class="headerlink" title="“进化方法” 和 “决策梯度方法” 概论"></a>“进化方法” 和 “决策梯度方法” 概论</h1><p>进化方法是我在学习“强化学习”这本书之前认为的在人工智能中必然要有的一个部分，但是本书给了我一盆冷水，本书作者认为进化算法对强化学习的作用不太明显，或者说缺点更多，不适合用作强化学习的方法。<br>但是我认为AI如果能达成，一定是模拟人或者动物的智慧形成过程的，即使进化方法不是学习技能（learn skills in individual lifetime）的主要方法，但是其对智慧的长期形成一定有非常重要影响，不能因为进化方法不适合强化学习的某些任务就彻底否定他，相反我们要注意他们的结合。<br>本书在讲述强化学习的过程中主要是围绕 Estimating Value Function展开的，但是Estimating Value Function在强化学习中不是必须的，Estimating Value Function前一篇介绍过<a href="https://face2ai.com/RL-RSAB-1-3-Elements-of-RL/。" target="_blank" rel="noopener">https://face2ai.com/RL-RSAB-1-3-Elements-of-RL/。</a></p><h2 id="进化方法-Evolution-Method"><a href="#进化方法-Evolution-Method" class="headerlink" title="进化方法(Evolution Method)"></a>进化方法(Evolution Method)</h2><p>在wiki上有进化的详细解释，如果有对进化算法不了解的同学可以大概看看或者自己google 。如果用概括性的语言描述一下，大概是这个样子的：</p><blockquote><p>进化方法，或者遗传算法是模拟生物繁殖时候基因交换，基因变异等过程来对某个Agent进行优化的方法</p></blockquote><p>举个例子：我们有一个任务M，我们模拟用10000个随机生成的Agent去完成任务，这些agnet是第一代，其中只有100个完成了；那么我们重新组合这100个的“基因”（按照各种设计的方法）产生10000个新的Agent，这些Agent就是第二代，去完成任务M，有200个成功了，继续进行第三代，第四代，直到找到一组或者多组稳定的“基因”能成功完成任务，这个过程就是进化方法，其主要过程在于组合基因和淘汰不满足对象。<br>类似的进化过程，进化算法，以及模拟退火等优化方法都是类似的套路。</p><p>这类方法是没有 Estimating Value Function 的</p><p>这就是本文的一个关键结论。</p><p>通过我们上面例子的描述可以发现，我们的进化算法只有“生”和“死”，比如产生新的agent是生，淘汰agent则是死，agent的全部能力全部来自遗传，这从人类进化的角度来看是不对，我们并不是靠生孩子进化到如此的，每个agent在有生之年不多研究进去，我们的人类才进化到现在的文明，作者也是这个观点，而且其对agent的有生之年的学习过程（agent自我完善policy的过程，人和动物完善自己的skill的过程）更加关注。<br>但是进化方法也是有些作用的，在某些强化学习问题中，进化方法也是可以使用的，一般这种问题有以下特点：</p><ol><li>Policy的搜索空间很小</li><li>Policy的搜索空间是结构化的，比较易于搜索</li><li>时间充足，比如这个训练程序可以跑一个世纪</li></ol><p>还有一种特殊的情况，就是在agent不能准确感知环境(Environment)的状态(State)的时候，进化方法很有用处.<br>这个也可以跟生物进化联系起来，在最初的地球，没有生物，有机物出现，第一个有机体出现，他们有任何感知能力，只能通过遗传，变异这种方式获得适应环境的生物，在变异出器官组织后，才能对环境进行感知互动，进化自己的policy</p><p>本书（本系列博客）主要重点在于agent在和环境interact的时候的“学习”，而进化方法就没这个过程，并且在interaction的过程中的细节，是agent进化的一个重要信息来源，这些细节信息使用起来会使得policy 的搜索更加高效，<br>所以我们可以总结一下进化方法在强化学习过程中的几个缺点：</p><ul><li>忽视太多强化学习问题背后的结构信息</li><li>舍弃了搜索policy过程中其实是一个函数，来对应state和action（进化算法没有这个）</li><li>忽略了agent的lifetime的policy选择和他所处的环境和状态等信息。</li></ul><p>虽然agent当前的state可能是错误的，就是agent可能是判断错误了（偶尔会出现这种问题），但是这并不影响这些信息（state，action等）对学习过程的帮助。</p><p>“进化方法”和“学习过程”（主要指agent自我修正调整policy的过程）在自然过程中有很多相同的特征，但是其目前看来确实不适合强化学习问题，所以本书（本系列博客）中的强化学习方法一般不包括进化方法</p><h2 id="决策梯度方法-Policy-Gradient-Method"><a href="#决策梯度方法-Policy-Gradient-Method" class="headerlink" title="决策梯度方法(Policy Gradient Method)"></a>决策梯度方法(Policy Gradient Method)</h2><p>这里有一个类似进化方法的学习方法，我们会在后面经常用到，这也是一个非常简单的方法，可以解决一些小的问题，叫做 “决策梯度方法”（Policy Gradient Method）<br>这种方法的特点是agent中的参数是有限的，换句话说，这个空间是离散且有限的，注意离散和不连续是两回事，有限的离散的空间参数个数是固定的，这样的话搜索空间会被缩小到很小，并且存在理论上的最优解，这种方法在有限的参数空间调整自己的policy来获得更好的reward，这个调整过程有点像进化算法的组合那一步，但是不同的是，这里的调整要根据agent和state之间的action来调整，而进化方法的调整方法是不关心这些信息的，所以他们有类似，但是又大不同。<br>决策梯度方法和其他的强化学习方法没有什么严格的定义区别，所以没有必要过于计较区分算法的归类。</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>本文介绍了进化方法和强化学习之间的一些关系，以及决策梯度方法之间的一些知识，注意进化方法是没有Estimating Value Function 的，这是问题的关键。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>Sutton R S, Barto A G. Reinforcement learning: An introduction[J]. 2011.</p><p>原文地址：<a href="https://www.face2ai.com/RL-RSAB-1-4-0-Limitations-and-Scope">https://www.face2ai.com/RL-RSAB-1-4-0-Limitations-and-Scope</a>转载请标明出处</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt;  本文介绍强化学习中的一些局限（limitation）和机遇（scope），介绍进化方法和决策梯度方法的区别和优劣&lt;br&gt;&lt;strong&gt;Keywords:&lt;/strong&gt; Evolutionary Method，进化方法，Policy Gradient Methods，决策梯度方法&lt;/p&gt;
    
    </summary>
    
      <category term="Reinforcement Learning" scheme="http://www.face2ai.com/categories/Reinforcement-Learning/"/>
    
      <category term="RL-An Introduction" scheme="http://www.face2ai.com/categories/Reinforcement-Learning/RL-An-Introduction/"/>
    
    
      <category term="强化学习" scheme="http://www.face2ai.com/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="进化方法" scheme="http://www.face2ai.com/tags/%E8%BF%9B%E5%8C%96%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【强化学习】1.3 强化学习的基础元素</title>
    <link href="http://www.face2ai.com/RL-RSAB-1-3-Elements-of-RL/"/>
    <id>http://www.face2ai.com/RL-RSAB-1-3-Elements-of-RL/</id>
    <published>2018-09-12T13:51:01.000Z</published>
    <updated>2018-10-07T09:10:24.809Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Abstract:</strong> 本文介绍除了agent和environment以外的，对于强化学习最重要的最基础的四个元素。<br><strong>Keywords:</strong> Policy，策略，Reward Signal，奖励，Value Function，评价函数，Model of Environment，环境模型</p><a id="more"></a><h1 id="强化学习的基础元素"><a href="#强化学习的基础元素" class="headerlink" title="强化学习的基础元素"></a>强化学习的基础元素</h1><p>前面我们说到了几个生活中的例子，和几个RL中基本模型，本文我们继续深入，探索目前强化学习中最基本的组成元素。</p><h2 id="策略-Policy"><a href="#策略-Policy" class="headerlink" title="策略(Policy)"></a>策略(Policy)</h2><p>策略是我的翻译，我不知道“正确”的翻译是什么，但是我们还是老原则，用英文。书中的定义是</p><blockquote><p>A policy defines the learning agent’s way of behaving at a given time.</p></blockquote><p>换成中文，我觉得更接地气一点的就是Policy就是agent的在任意时刻的产生行为的依据，也就是说agent，或者人或者动物或者robot，在某一时刻，有明确的最终目的，但是此时此刻，面对这个时间点的环境的时候，他要产生某种规则的方式，就是policy。如果用数学的的形式就是<br>$$<br>f(环境)\to 行为<br>$$<br>这里面的 $f$ 是个映射，是不是函数不一定，这个映射，综合当前的所有环境信息，产生一个action。最简单的例子，这个policy可以是个映射表，当出现什么环境的时候，就做出什么样的决定，如果你穷举了下棋的所有棋局，那么每种盘面都对应了最佳的走法，我们把这个对应走法记录在一章表上，那么这个表（中的内容）就是policy</p><p>心理学中把这个叫做刺激反应法则（stimulus-response rule）或者叫做 association（翻译不出来）<br>Policy可以是非常简单的规则，比如自动驾驶看到红灯要停车，也可以及其复杂，比如自动驾驶要把在菜市场里的车开出来。<br>Policy是agent面对环境做出action的核心，但是这个核心有时候也可以是随机的，换句话说，上面那张“表”里面的信息可能是随机——有时候随机并不代表不可靠</p><h2 id="奖励信号-Reward-Signal"><a href="#奖励信号-Reward-Signal" class="headerlink" title="奖励信号(Reward Signal)"></a>奖励信号(Reward Signal)</h2><p>激励信号，或者奖励信号，书中的定义：</p><blockquote><p>A reward signal defines the goal in a reinforcement leaning problem</p></blockquote><p>激励信号，就是agent的得分，目前我们的研究的agent在每一步都有来自环境的反馈，由于我们没有所谓的有teacher，所以我们会通过一个我们设计的[reward函数]，来计算出每一步我们得到的评分，而agent存在的目的就是在他的生命周期内最大化这个得分的总和。<br>reward signal是agent来自每一个action之后环境给与的反馈，得分定义这个action的好坏，以及好坏的程度；类似于生物中，对于刺激的反应，是表示舒服还是难受。<br>这个goal是立刻的明确的，不能有延迟以及模棱两可的评分，或者说是客观公正的，不能被agent改变的，换句话说，这个goal是公正的，agent不能又当运动员又当裁判。agent只能通过根据环境改变自己的行为来最大化自己的goal，评判有专门的[裁判]（后面会说到）。<br>agent不断学习新的知识来提高自己的得分，其工作方法是改变自己的policy，所以reward signal 就成了调整policy的主要依据了。<br>同样这个裁判也有可能是随机，没错，一个疯了的裁判，至于为什么会有这种情况，我也不知道后面会不会涉及。<br>第三章我们会介绍这个reward 函数对于agent不变是有生物学原理的，原理来自我们的大脑。</p><h2 id="值函数-Value-Function"><a href="#值函数-Value-Function" class="headerlink" title="值函数(Value Function)"></a>值函数(Value Function)</h2><p>注意区分，Reward Function 和Value Function是不同的两个函数，作用不同，性质不同。书中的定义：</p><blockquote><p>Whereas the reward signal indicates what is good in an immediate sense, a value function specifies what is good in the long run.</p></blockquote><p>用中文说就是，reward是每次的结果，value function是来预测这个agent到最后能得到的总分。value function有一定的预测行为在里面，包括后面可能出现的情况，而这些情况是否发生目前是不确定的，一个类似的例子就是，你在准备高考，参加了两次模拟考试，reward是你这两次模拟考试的好坏，而value函数是要预测你最终高考结果的。<br>很有可能出现这种情况，前面几个step的reward 都很低，但是value function却依然很好。反之亦然会出现。</p><p>在RL中reward是最主要的，value function次之。如果没了reward那么agent就是无头苍蝇，而且没有reward就没了value的概念。value更像是辅助agent 来得到更多reward的参考书。<br>然而，agent做决定的时候有时候更多的考虑value function，这个原因是我们的RL最终目标是得到更高的reward总和，而不是某一步的reward，所以这会给我们一个错觉，就是value function比reward要更重要。<br>作为得到更多reward的参考，value的获得更加复杂，比获得reward要复杂的多，reward依据当前环境给出，而value是依据后面的环境给出，一个是静态的，一个是动态的（环境在变，agent的policy也在变）<br>在一般的RL算法的重要组成就是要找到有效value预测值，这个工作会是未来几十年的重点研究方向</p><h2 id="环境模型-Model-of-Environment"><a href="#环境模型-Model-of-Environment" class="headerlink" title="环境模型(Model of Environment)"></a>环境模型(Model of Environment)</h2><p>最后一个就是环境模型，环境是个很大的很抽象的概念，环境模型和环境并不是一会儿事，但是关系密切。</p><p>某个state下，agent的某个action可能会获得什么样的反馈，环境模型可以预测这个反馈，而实际的反馈是环境根据state和action给出的，所以环境模型越接近环境，就会越准确，环境模型更多的用来做Planning，就是agent在做action之前“思考，计划”<br>使用环境模型和planning进行的RL，我们称之为“基于模型的方法”，相反，就是“不基于模型的方法”<br>不基于环境模型的方法是更直接的trail-and-error 方式，经常被看做是planning方式的对立方法。但是第八章，会介绍同时使用 trail-and-error 和 模型以及planning 的方法。<br>基于模型的方法会跨越我们RL中各种层级：low-level, trail-and-error, high level以及deliborating planning。</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>本文介绍了强化学习的四种基本组成元素，不但基础而且非常重要，基本就是后面所有的研究对象了。需要好好研究。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol><li>Sutton R S, Barto A G. Reinforcement learning: An introduction[J]. 2011.</li></ol><p>原文来自：<a href="https://face2ai.com/RL-RSAB-1-3-Elements-of-RL" target="_blank" rel="noopener">https://face2ai.com/RL-RSAB-1-3-Elements-of-RL</a>转载标明出处</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; 本文介绍除了agent和environment以外的，对于强化学习最重要的最基础的四个元素。&lt;br&gt;&lt;strong&gt;Keywords:&lt;/strong&gt; Policy，策略，Reward Signal，奖励，Value Function，评价函数，Model of Environment，环境模型&lt;/p&gt;
    
    </summary>
    
      <category term="Reinforcement Learning" scheme="http://www.face2ai.com/categories/Reinforcement-Learning/"/>
    
      <category term="RL-An Introduction" scheme="http://www.face2ai.com/categories/Reinforcement-Learning/RL-An-Introduction/"/>
    
    
      <category term="强化学习" scheme="http://www.face2ai.com/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
